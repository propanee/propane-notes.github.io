#  HTTP 常见面试题

1. HTTP 基本概念
2. Get 与 Post
3. HTTP 特性
4. HTTP 缓存技术
5. HTTPS 与 HTTP
6. HTTP/1.1、HTTP/2、HTTP/3 演变

## HTTP 基本概念

### HTTP 是什么？

HTTP 是超文本传输协议，也就是**H**yperText **T**ransfer **P**rotocol。**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」**

超文本协议传输可以拆成三个部分：超文本、传输、协议

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402281550128.png" alt="三个部分" style="zoom: 50%;" />

1. **「协议」**

针对 HTTP **协议**，我们可以这么理解。HTTP 是一个用在计算机世界里的**协议**。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（**两个以上的参与者**），以及相关的各种控制和错误处理方式（**行为约定和规范**）。

2. **「传输」**

针对**传输**，我们可以进一步理解了 HTTP。*HTTP 是一个在计算机世界里专门用来在**两点之间传输数据**的约定和规范。*

- HTTP 协议是一个**双向协议**。如浏览器是请求方 A，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕。

- 数据虽然是在 A 和 B 之间传输，但允许中间有**中转或接力**。

  就好像第一排的同学想传递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A < --- > B」，变成了「A <-> N <-> M <-> B」。而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/5-%E8%AF%B7%E6%B1%82%E5%BA%94%E7%AD%94.png" alt="请求 - 应答" style="zoom:50%;" />



3. **「超文本」**

HTTP 传输的内容是「超文本」。在互联网早期的时候「文本」只是简单的字符文字，「超文本」就是**超越了普通文本的文本**，它是文字、图片、视频等的混合体，最关键有**超链接**，能从一个超文本跳转到另外一个超文本。HTML本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。

> 「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议」，这种说法正确吗？
>
> 这种说法是**不正确**的。因为也可以是「服务器< -- >服务器」，所以采用**两点之间**的描述会更准确。



### HTTP 常见的状态码

![ 五大类 HTTP 状态码 ](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png)

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

---

`2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

- 「**200 OK**」是最常见的**成功状态码**，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
- 「**204 No Content**」与 200 OK 基本相同，但**响应头没有 body 数据**。
- 「**206 Partial Content**」是应用于 HTTP **分块下载或断点续传**，表示响应返回的 body 数据并不是资源的全部，而是其中的**一部分**。

----

`3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称**缓存重定向**，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

---

`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端**请求的报文有错误**，但只是个笼统的错误。
- 「**403 Forbidden**」表示服务器**禁止访问资源**，并不是客户端的请求出错。
- 「**404 Not Found**」表示请求的资源在服务器上**不存在或未找到**，所以无法提供给客户端。

---

`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 「**500 Internal Server Error**」与 400 类似，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

---



### HTTP 常见字段

***Host* 字段**

客户端发送请求时，用来指定服务器的域名。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402281601731.png" alt="img" style="zoom:50%;" />

```text
Host: www.A.com
```

有了 `Host` 字段，就可以将请求发往「同一台」服务器上的不同网站。

---

***Content-Length 字段***

服务器在返回数据时，会有 `Content-Length` 字段，表明告知浏览器**本次回应的数据长度**。后面的字节就属于下一个回应了。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402281602428.png" alt="img" style="zoom: 67%;" />

```text
Content-Length: 1000
```

大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，**HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题**。具体什么是 TCP 粘包，可以看这篇文章：[如何理解是 TCP 面向字节流协议？(opens new window)](https://xiaolincoding.com/network/3_tcp/tcp_stream.html)

---

***Connection 字段***

`Connection` 字段最常用于客户端要求服务器使用「**HTTP 长连接**」机制，以便其他请求复用。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402281604589.png" alt="img" style="zoom: 67%;" />

HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`。

```text
Connection: Keep-Alive
```

开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402281605138.png" alt="HTTP 长连接" style="zoom: 50%;" />



PS：大家不要把 HTTP Keep-Alive 和 TCP Keepalive 搞混了，这两个虽然长的像，但是不是一个东西，具体可以看我这篇文章：[TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？(opens new window)](https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html)

---

***Content-Type 字段***

`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402281607659.png" alt="img" style="zoom: 67%;" />

```text
Content-Type: text/html; Charset=utf-8
```

上面的类型表明，发送的是网页，而且编码是UTF-8。

客户端请求的时候，可以使用 `Accept` 字段声明自己可以接受哪些数据格式。

```text
Accept: */*
```

上面代码中，客户端声明自己可以接受任何格式的数据。

---

***Content-Encoding 字段***

`Content-Encoding` 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402281607282.png" alt="img" style="zoom: 67%;" />

```text
Content-Encoding: gzip
```

上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。

客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。

```text
Accept-Encoding: gzip, deflate
```

----



## GET 与 POST

### GET 和 POST 有什么区别？

根据 RFC 规范，**GET 的语义是从服务器获取指定的资源**，这个资源可以是静态的文本、页面、图片视频等。GET 请求的**参数位置一般是写在 URL 中**，URL 规定只能支持 **ASCII**，所以 GET 请求的参数只允许 ASCII 字符 ，而且**浏览器**会对 **URL 的长度**有限制（HTTP协议本身对 URL长度并没有做任何规定）。

比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402281623408.png" alt="GET 请求" style="zoom: 80%;" />

根据 RFC 规范，**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在**报文 body** 中，body 中的数据可以是**任意格式的数据**，只要客户端与服务端协商好即可，而且浏览器**不会对 body 大小**做限制。

比如，你在我文章底部，敲入了留言后点击「提交」，浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402281625856.png" alt="POST 请求" style="zoom: 80%;" />

### GET 和 POST 方法都是安全和幂等的吗？

- 在 HTTP 协议里，所谓的**「安全」**是指请求方法不会**破坏**服务器上的资源。
- 所谓的**「幂等」**，意思是多次执行相同的操作，结果都是**相同**的。

如果从 RFC 规范定义的语义来看：

- **GET 方法就是安全且幂等的**，因为它是*只读*操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，**可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签**。
- **POST** 因为是新增或提交数据的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以，**浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签**。

### GET 和 POST 小结

GET 的语义是**请求获取指定的资源**。GET 方法是**安全、幂等、可被缓存的**。

POST 的语义是**根据请求负荷（报文主体）对指定的资源做出处理**，具体的处理方式视资源类型而不同。POST **不安全，不幂等，（大部分实现）不可缓存**。

但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：

- 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。
- 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。

> 如果「安全」放入概念是指信息是否会被泄漏的话，虽然 POST 用 body 传输数据，而 GET 用 URL 传输，这样数据会在浏览器地址拦容易看到，但是并不能说 GET 不如 POST 安全的。
>
> 因为 **HTTP 传输的内容都是明文的**，虽然在浏览器地址拦看不到 POST 提交的 body 数据，但是只要抓个包就都能看到了。
>
> 所以，要避免传输过程中数据被窃取，就要使用 **HTTPS 协议**，这样所有 HTTP 的数据都会被**加密**传输。

> GET 请求可以带 body 吗？
>
> RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。
>
> 另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。

----



## HTTP 缓存技术

### HTTP 缓存有哪些实现方式？

对于一些具有**重复性**的 HTTP 请求，比如每次请求得到的数据都一样的，可以把这对「请求-响应」的数据都**缓存在本地**，下次就可以直接读取本地数据，不必通过网络获取服务器的响应，这样 HTTP/1.1 的性能肯定肉眼可见的提升。

通过**缓存技术**能够避免发送 HTTP 请求， 因此HTTP 协议的头部有不少是针对缓存的字段。

HTTP 缓存有两种实现方式，分别是**强制缓存和协商缓存**。

### 什么是强制缓存？

强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的**主动性在于浏览器**这边。

如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。

<img src="https://cdn.xiaolincoding.com//mysql/other/1cb6bc37597e4af8adfef412bfc57a42.png" alt="img" />

强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：

- `Cache-Control`， 是一个相对时间；
- `Expires`，是一个绝对时间；

如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control 的优先级高于 Expires** 。

Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
- 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
- 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。

### 什么是协商缓存？

某些请求的响应码是 `304`，这是告诉浏览器可以使用本地缓存的资源，通常这种**通过服务端告知客户端**是否可以使用缓存的方式被称为协商缓存。**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。



<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png" alt="img" style="zoom:50%;" />

协商缓存可以基于两种头部来实现。

第一种：**请求头部中的 `If-Modified-Since`** 字段与**响应头部中的 `Last-Modified`** 字段实现，这两个字段的意思是：

- **响应头部**中的 `Last-Modified`：标示这个响应资源的**最后修改时间**；
- **请求头部**中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），**如果最后修改时间较新（大）**，**说明资源又被改过，则返回最新资源**，HTTP 200 OK；如果最后修改时间较旧（小），说明**资源无新修改**，响应 HTTP **304** 走缓存。

第二种：**请求**头部中的 `If-None-Match` 字段与**响应**头部中的 `ETag` 字段，这两个字段的意思是：

- **响应**头部中 `Etag`：**唯一标识**响应资源；
- **请求**头部中的 `If-None-Match`：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将**请求头 If-None-Match 值设置为 Etag 的值**。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。

第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，**这时 Etag 的优先级更高**，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。

**为什么 ETag 的优先级更高？**这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：

1. 在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；
2. 可能有些文件是在秒级以内修改的，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；
3. 有些服务器不能精确获取文件的最后修改时间。

注意，**协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png" alt="img" style="zoom:50%;" />

当使用 ETag 字段实现的协商缓存的过程：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个**唯一标识的值是根据当前请求的资源生成的**；
- 当浏览器再次请求访问服务器中的该资源时，首先会**先检查强制缓存**是否过期：
  - 如果没有过期，则直接使用本地缓存；
  - 如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；
- 服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：
  - **如果值相等，则返回 304 Not Modified，不会返回资源**；
  - 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
- 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。

----



## HTTP 特性

到目前为止，HTTP 常见到版本有 HTTP/1.1，HTTP/2.0，HTTP/3.0，不同版本的 HTTP 特性是不一样的。

### HTTP/1.1 的优点

HTTP 最突出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。

**1. 简单**

HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。

**2. 灵活和易于扩展**

HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。

同时 HTTP 由于是工作在应用层（ `OSI` 第七层），则它**下层可以随意变化**，比如：

- **HTTPS** 就是在 HTTP 与 TCP 层之间增加了 **SSL/TLS 安全传输层**；
- **HTTP/1.1 和 HTTP/2.0** 传输协议使用的是 **TCP** 协议，而到了 **HTTP/3.0** 传输协议改用了 **UDP** 协议。

**3. 应用广泛和跨平台**

互联网发展至今，HTTP 的应用范围非常的广泛，同时天然具有**跨平台**的优越性。

### HTTP/1.1 的缺点

**1. 无状态双刃剑**

- **好处**，服务器不会去记忆 HTTP 的状态，不需要额外的资源记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务；

- **坏处**，服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。

  例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。

对于无状态的问题，解法方案有很多种，其中比较简单的方式用 **Cookie** 技术。

`Cookie` 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。相当于，**在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/14-cookie%E6%8A%80%E6%9C%AF.png" alt="Cookie 技术" style="zoom: 67%;" />

**2. 明文传输双刃剑**

- 好处：明文意味着在传输过程中的信息，是可方便阅读的，比如 Wireshark 抓包都可以直接肉眼查看，**为我们调试工作带了极大的便利性**。

- 坏处：信息裸奔，隐私暴露；

**3. 不安全**

- 窃听风险：通信使用**明文（不加密）**，内容可能会被窃听。
- 冒充风险：**不验证通信方的身份**，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多。
- 篡改风险：**无法证明报文的完整性**，所以有可能已遭篡改。比如，网页上植入垃圾广告。

HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 **SSL/TLS 层**，使得在安全上达到了极致。

### HTTP/1.1 的性能

HTTP 协议基于 **TCP/IP**，并使用了「**请求 - 应答**」的通信模式，性能的关键就在这**两点**里。

1.**长连接**

早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。

HTTP/1.1 提出了**长连接**的通信方式，也叫持久连接，减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

当然，如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/16-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="短连接与长连接" style="zoom: 67%;" />

2.**管道网络传输**

HTTP/1.1 采用了长连接的方式，这使得**管道（pipeline）网络传输**成为了可能。即可在同一个 TCP 连接里面，客户端可以**发起多个请求**，只要第一个请求发出去了，不必等待服务器回应，就可以发第二个请求出去，可以**减少整体的响应时间。**

举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求；

但是**服务器必须按照接收请求的顺序发送对这些管道化请求的响应**。如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。

所以，**HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.png" alt="管道网络传输" style="zoom:80%;" />

> **注意!!!**
>
> 实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以**后面所有文章讨论 HTTP/1.1 都是建立在没有使用管道化的前提**。大家知道有这个功能，但是没有被使用就行了。

3.**队头阻塞**

「请求 - 应答」的模式会造成 HTTP 的性能问题。因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」，好比上班的路上塞车。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/18-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.png" alt="队头阻塞" style="zoom: 80%;" />

----

##  HTTP 与 HTTPS

### HTTP 与 HTTPS 区别

- HTTP 信息是**明文传输**，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，**在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议**，使得报文能够加密传输。
- HTTP 连接建立相对简单， **TCP 三次握手**之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 **SSL/TLS 的握手过程**，才可进入加密报文传输。
- 两者的**默认端口**不一样，HTTP 默认端口号是 **80**，HTTPS 默认端口号是 **443**。
- HTTPS 协议需要向 **CA（证书权威机构）申请数字证书**，来保证服务器的身份是可信的。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402292008319.jpeg" alt="HTTP 与 HTTPS 网络层" style="zoom: 67%;" />

### HTTPS 是如何解决HTTP三个风险的

HTTP**S** 在 HTTP 与 TCP 层之间加入了 `SSL/TLS` 协议，很好的解决窃听、篡改、冒充风险：

- **混合加密**的方式实现信息的**机密性**，解决了窃听的风险。
- **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
- 将服务器公钥放入到**数字证书**中，解决了冒充的风险。

1.**混合加密**

HTTPS 采用的是**对称加密**和**非对称加密**结合的「混合加密」方式：

- 在通信建立前采用**非对称加密**的方式交换「会话秘钥」；
- 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

采用「混合加密」的方式的**原因**：

- **非对称加密**使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。
- **对称加密**只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402292208838.png" alt="混合加密" style="zoom:67%;" />

2.**摘要算法 + 数字签名**

**用摘要算法（哈希函数）来计算出内容的哈希值**，也就是内容的「指纹」，这个**哈希值是唯一的，且无法通过哈希值推导出内容**。接收方同样对内容做哈希，如果不同则证明被篡改了。

通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**。

为了避免这种情况，计算机里会用**非对称加密算法**来解决，共有两个密钥：

- 一个是公钥，这个是可以公开给所有人的；
- 一个是私钥，这个必须由本人管理，不可泄露。

这两个密钥可以**双向加解密**的，

- **公钥加密，私钥解密**。目的是**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
- **私钥加密，公钥解密**。目的是**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

一般不会用非对称加密来加密实际的传输内容，因为计算比较耗费性能。所以非对称加密主要用于**通过「私钥加密，公钥解密」的方式，来确认消息的身份**，我们常说的**数字签名算法**，就是用的是这种方式，不过私钥加密是**对内容的哈希值加密**。

**私钥**由**服务端**保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被**公钥解密**，就说明该消息是由服务器发送的。

- 通过哈希算法来保证消息的完整性；
- 通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402292214580.png" alt="img" style="zoom: 67%;" />

3.**数字证书**

在计算机里，这个权威的机构就是 **CA （数字证书认证机构）**，将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402292219331.jpeg" alt="数子证书工作流程" style="zoom:67%;" />



----

----

----



# 既然有 HTTP 协议，为什么还要有 RPC？

## 从 TCP 聊起

作为一个程序员，需要在 A 电脑的进程发一段数据到 B 电脑的进程，一般会在代码里使用 Socket 进行编程。这时候一般也就 TCP 和 UDP 二选一，类似下面这样。

```c
fd = socket(AF_INET,SOCK_STREAM,0);
```

其中 `SOCK_STREAM`，是指使用**字节流**传输数据，说白了就是 **TCP 协议**。

在定义了 Socket 之后，我们就可以愉快的对这个 Socket 进行操作，比如用 `bind()` 绑定 IP 端口，用 `connect()` 发起建连。在连接建立之后，我们就可以使用 `send()` 发送数据，`recv()` 接收数据。

光这样一个纯裸的 TCP 连接，就可以做到收发数据了，但还不行，这么用会有问题。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202403021038931.gif" alt="握手建立连接流程" style="zoom:67%;" />

## 使用纯裸 TCP 会有什么问题

TCP 是有三个特点，**面向连接**、**可靠**、基于**字节流**。

字节流可以理解为一个双向的通道里流淌的二进制数据，纯裸 TCP 收发的这些数据之间是**没有任何边界**的，即不知道一条完整的消息在哪里结束，这就是所谓的**粘包问题**（[如何理解TCP是面向字节流协议？](.\TCP#如何理解TCP是面向字节流协议？)）。

所以纯裸 TCP 是不能直接拿来用的，需要在这个基础上加入一些**自定义的规则**，用于区分**消息边界**。比如加入**消息头**，**消息头里写清楚一个完整的包长度是多少**。

而这里头提到的**消息头**，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的**协议。**

**于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。**

##  HTTP 和 RPC

我们回过头来看网络的分层图。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202403022222390.png" alt="四层网络协议" style="zoom:50%;" />

**TCP 是传输层的协议**，而基于 TCP 造出来的 HTTP 和各类 RPC 协议，它们都只是定义了不同消息格式的**应用层协议**而已。

**HTTP超文本传输协议**用的比较多，在浏览器上敲个网址就能访问网页，用到的就是 HTTP 。

**RPC**（**R**emote **P**rocedure **C**all），又叫做**远程过程调用**。它本身并不是一个具体的协议，而是一种**调用方式**。我们平时调用一个**本地方法**就像下面这样。

```text
 res = localFunc(req)
```

如果现在这是个**远端服务器**暴露出来的一个方法 `remoteFunc`，还能像调用本地方法那样去调用它，就可以**屏蔽掉一些网络细节**。

```text
 res = remoteFunc(req)
```

![RPC可以像调用本地方法那样调用远端方法](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202403022224906.png)

基于这个思路，产生了比较有名的`gRPC`，`thrift`。虽然大部分 RPC 协议底层使用 TCP，但实际上**不一定非得使用 TCP，改用 UDP 或者 HTTP**，也可以做到类似的功能。

### 既然有 HTTP 协议，为什么还要有 RPC？

其实，`TCP` 是**70年**代出来的协议，而 `HTTP` 是 **90 年代**才开始流行的。而直接使用裸 TCP 会有问题，这中间有很多自定义的协议，这里面就有**80年代**出来的 `RPC`。所以该问的不是既然有 HTTP 协议为什么要有 RPC，而是**为什么有 RPC 还要有 HTTP 协议**。

### 那既然有 RPC 了，为什么还要有 HTTP 呢？

- 现在电脑上各种联网软件都作为客户端（Client）需要跟服务端（Server）建立连接收发消息，都会用到应用层协议，在这种 **Client/Server (C/S)** 架构下，可以使用自家造的 RPC 协议，只管连自己公司的服务器就 ok 了。
- **浏览器（Browser）**不仅要能访问自家公司的服务器（Server），还要访问其他公司的网站服务器，因此需要统一的标准，HTTP 就是用于统一 **Browser/Server (B/S)** 的协议。

也就是说在多年以前，**HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构**。但现在B/S 和 C/S 在慢慢融合，很多软件同时支持多端，比如支持网页版、手机端和 PC 端，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。**RPC** 就开始退居幕后，一般用于公司内部集群里，**各个微服务之间的通讯**。

## HTTP 和 RPC 的区别

### 服务发现

向某个服务器发起请求，首先需要建立连接，前提是需要知道服务对应的 **IP 地址和端口**，这个过程就是**服务发现**。

- 在 **HTTP** 中，知道服务的域名，就可以通过 **DNS 服务**解析得到IP 地址，默认 80 端口。
- 在 **RPC** 中 ，一般会有专门的**中间服务**去保存服务名和IP信息，比如 **Consul 或者 Etcd，甚至是 Redis**。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如**CoreDNS**。

可以看出服务发现这一块，两者是有些区别，但不太能分高低。

### 底层连接形式

- 以主流的 **HTTP/1.1** 为例，默认在建立底层 TCP 连接之后会一直保持这个连接（**Keep Alive**），之后的请求和响应都会复用这条连接。
- **RPC** 协议也是建立 TCP 长链接进行数据交互，不同在于，RPC 一般还会再建个**连接池**，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，**用完放回去，下次再复用**。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202403022244412.png" alt="connection_pool" style="zoom:50%;" />

由于**连接池有利于提升网络请求性能**，所以不少编程语言的网络库里都会**给 HTTP 加个连接池**，比如 **Go** 就是这么干的。

可以看出这一块两者也没太大区别，所以也不是关键。

### 传输的内容

基于 TCP 传输的消息，说到底，无非都是**消息头 Header 和消息体 Body。**

- **Header** 用于标记一些特殊信息，其中最重要的是**消息体长度**。
- **Body** 则是放真正需要传输的内容且只能是二进制 01 串。对于字符串和数字问题都不大，如字符串转成编码后变为01串。而将**结构体**转为二进制 01 串的方案现在也有很多现成的，比如 **Json，Protobuf。**

将结构体转为二进制数组的过程就叫**序列化**，反过来将二进制数组复原成结构体的过程叫**反序列化**。

对于主流的 HTTP/1.1，虽然它现在叫**超文本**协议，支持音频视频，但 HTTP 设计初是用于做网页**文本**展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 **Json** 来**序列化**结构体数据。

<img src="https://cdn.xiaolincoding.com//mysql/other/324cbe84c303a3b975e50329f5cdbf8b.png" alt="HTTP 报文" style="zoom: 33%;" />

这里面的内容非常多的**冗余**，显得**非常啰嗦**。最明显的，像 `Header` 里的那些信息，其实如果我们约定好头部的第几位是 Content-Type，就**不需要每次都真的把"Content-Type"这个字段都传过来**，类似的情况其实在 `body` 的 Json 结构里也特别明显。

而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。**因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。**

![HTTP 原理](https://cdn.xiaolincoding.com//mysql/other/f4cef7331cabcfe56d9d6434f7ef907f.png)

当然上面说的 HTTP，其实**特指的是现在主流使用的 HTTP/1.1**，`HTTP/2` 在前者的基础上做了很多改进，所以**性能可能比很多 RPC 协议还要好**，甚至连 `gRPC` 底层都直接用的 `HTTP/2`。

> 那么问题又来了，为什么既然有了 HTTP/2，还要有 RPC 协议？

这个是由于 HTTP/2 是 2015 年出来的。那时候很多公司内部的 RPC 协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。![RPC 原理](https://cdn.xiaolincoding.com//mysql/other/12244fb0b19b2e61755fcab799198f68.png)