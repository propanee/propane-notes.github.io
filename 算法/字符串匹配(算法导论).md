

# 字符串匹配(String matching)

## 有限自动机(finite automata)

只对每个文本字符检查一次且检查每次检查所用的时间为常数。首先通过预处理模式构建自动机，预处理时间为$\Theta(m|\Sigma|)$ ，然后对文本进行匹配，匹配时间为$\Theta(n)$。

一个有限自动机 $M$ 是一个 5 元组 $(Q,q_0,A,\Sigma,\delta )$ ，其中：

* $Q$ 是有限状态(state)集。
* $q_0\in Q$ 是起始状态(start state)。
* $A\subseteq Q$ 是接受状态(accepting state)集。
* $\Sigma$ 是有限输入字母表(input alphabet)。
* $\delta$ 是一个从 $Q\times\Sigma$ 到 $Q$ 的函数，称为 $M$ 的转移函数(transition function)。

终态函数(final-state function) $\phi$ ，它是从 $\Sigma^*$ 到 $Q$ 的函数， $\phi(w)$ 是 $M$ 在读取字符串 $w$ 后终止时的状态。因此，$M$ 接受字符串 $w$ 当且仅当 $\phi(w)\in A$ 。我们可以用转移函数递归定义 
$$
\begin{align}
&\phi(\varepsilon) = q_0 
\\&\phi(wa) = \delta(\phi(w),a), w\in \Sigma^*, a\in \Sigma
\end{align}
$$
对应于模式$P$的后缀函数(suffix function) $\sigma(x) = \max\{k:P[:k]\sqsupset x\}$。函数 $\sigma$ 将 $\Sigma^*$ 映射到 $ \{0, 1,\dots , m\}$， 满足$\sigma(x)$ 是 $P$ 的前缀的最大长度。例如，对于模式 $P=\rm ab$ ，有 $\sigma(\varepsilon) = 0$ ， $\sigma({\rm caca}) = 1$ ， $\sigma({\rm ccab}) = 2$ 。

对于一个给定的模式 $P$ ，我们可以在预处理阶段构造出一个模式 $P$ 的字符串匹配自动机，然后自动机在文本字符串中搜索 $P$ 的出现位置。下面说明了构造一个模式 $P= \rm ababaca$ 的有限自动机的过程。

<img src="C:\Users\cbw\AppData\Roaming\Typora\typora-user-images\image-20231118194946701.png" alt="image-20231118194946701" style="zoom: 67%;" />

自动状态机，初始状态为0，唯一接受的状态为m，复杂度。

$\begin{flalign} &\text{FINITE-AUTOMATON-MATCHER}(T,\delta,m)
\\ 1&\quad n= T.length
\\ 1&\quad q= 0 
\\ 2&\quad \text{for }i = 0\text{ to }n
\\ 3&\qquad q = \delta(q,T[i])
\\ 4&\qquad \text{if }q==m 
\\ 5&\qquad\qquad \text{print Pattern occurs with shift }i-m &
\\ \end{flalign}$

根据给定模式 $P[1:m]$ 计算转移函数 $\delta$ ，复杂度$O(m|\Sigma|)$：

$\begin{aligned} 
&\text{COMPUTE-TRANSITION-FUNCTION}(P,\Sigma)
\\ 1&\quad m=P.length
\\ 2&\quad \text{for }q = 0\text{ to }m
\\ 3&\qquad \text{for each character }a\in\Sigma
\\ 4&\qquad\quad k = \min\{m+1,q+2\}
\\ 5&\qquad\quad \text{while }P[:k]\text{ is not a suffix of }P[:q]a
\\ 6&\qquad\qquad k = k-1
\\ 7&\qquad\quad \delta(q,a) = k
\\ 8&\quad \text{return }\delta
\end{aligned}$ 

**定理 32.4 (Theorem 32.4)**

若 $\phi$ 是对于给定模式 $P$ 的字符串匹配自动机的终泰函数， $T[1:n]$ 是该自动机的输入文本，则对于 $i = 0,1,\dots, n$ ，有 $\phi(T[:i]) = \sigma(T[:i])$ 。

归纳基础：当 $i=0$ 时，因为 $T[:0]=\varepsilon$ ，所以 $\phi(T[:0])=0= \sigma(T[:0])$ ，该定理显然成立。

归纳假设： $\phi(T[:i]) = \sigma(T[:i])$ 。

归纳步骤：设 $q=\phi(T[:i])$ ，有 $q = \sigma(T[:i])$ ，设 $a = T[i+1]$ ，

$\begin{aligned} \phi(T[:i+1]) &= \phi(T[:i]a)&&(\text{by the definitions of }T[:i+1]\text{ and }a)\\ &=\delta(\phi(T[:i]),a)&&(\text{by the definitions of }\phi)\\ &=\delta(q,a)&&(\text{by the definitions of }q)\\ &=\sigma(P[:q]a)&&(\text{by the definitions (32.4 )of }\delta)\\ &=\sigma(T[:i]a)&&(\text{by Lemma 32.3})\\ &=\sigma(T[:i+1])&&(\text{by the definition of }T[:i+1])\\ \end{aligned}$ 

评：最后一行 $=(T[:i+1])$ 需要修正为 $=\sigma(T[:i+1])$ 。

# KMP

预先计算辅助函数$\pi$ 替代转移函数$\delta$。可以根据模式在$\Theta(m)$时间内预先计算，并且存储在数组 $\pi[1:m]$ 中，比$\delta$的计算时间少了$|\Sigma|$。$\pi[q]$的值包含了与 $a$ 无关但在计算 $\delta(q, a)$ 时需要的信息，按需动态地计算转移函数$\delta$。

主要思想：**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。**

## 模式的前缀函数

模式的前缀函数 $\pi$ 包含模式与其所有偏移后自身进行匹配的信息。这些信息可用于在朴素的字符串匹配算法中避免对无用偏移进行检测，也可以避免在字符串匹配自动机中，对整个转移函数 $\delta$ 的预先计算。

![image-20231118220434420](C:\Users\cbw\AppData\Roaming\Typora\typora-user-images\image-20231118220434420.png)

给定一个模式 $P[1:m]$ ， $P$ 的前缀函数(prefix function) 是函数$\pi: \{1,2, \dots ,m\}  \rightarrow \{0,1,\dots, m-1\}$ ，满足 
$$
\pi[q] = \max\{k : k < q \land P[:k]\sqsupset P[:q]\}
$$
即$\pi[q]$是$P[:q]$的真后缀且是P的最长前缀的长度。

![image-20231118222507266](C:\Users\cbw\AppData\Roaming\Typora\typora-user-images\image-20231118222507266.png)

什么是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配。此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。

过程 KMP-MATCHER 描述了 Knuth-Morris-Pratt 算法，该过程大部分与 FINITE-AUTOMATON-MATCHER 一致，不同之处在于有限自动机方法是调用转移函数 $\delta$ 进行转移，Knuth-Morris-Pratt 算法是调用前缀函数 $\pi$ 进行偏移，KMP-MATCHER 调用了一个辅助过程 COMPUTE-PREFIX-FUNCTION 来计算前缀函数 $\pi$ 。

$\begin{aligned} &\text{KMP-MATCHER}(T, P, n,m)\\ 
1&\quad \pi = \text{COMPUTE-PREFIX-FUNCTION}(P,m)\\
2&\quad q = 0\qquad\color{red}{\text{// number of characters matched}}\\ 
3&\quad\text{for }i=1\text{ to } n \qquad\color{red}{\text{// scan the text from left to right}}\\ 
4&\qquad \text{while }q>0\text{ and }P[q+1]\ne T[i]\\
5&\qquad\quad q = \pi[q]\qquad\color{red}{\text{// next character does not match}}\\ 
6&\qquad \text{if }P[q+1] == T[i]\\ 
7&\qquad\quad q = q+1\qquad\color{red}{\text{// next character matches}}\\ 
8&\qquad\text{if }q==m \qquad\color{red}{\text{// is all of }P\text{ matched?}}\\ 
9&\qquad\quad \text{print Pattern occurs with shift }i-m\\ 
10&\qquad\quad q = \pi[q]\qquad\color{red}{\text{// look for the next match}}\\ 
\end{aligned}$ 

$\begin{aligned} &\text{COMPUTE-PREFIX-FUNCTION}(P,m)\\ 
1&\quad \text{let }\pi[1:m]\text{ be a new array}\\ 
2&\quad \pi[1] = 0\\ 
3&\quad k = 0\\ 
4&\quad \text{for }q=2\text{ to }m\\ 
5&\qquad \text{while }k>0\text{ and }P[k+1]\ne P[q]\\ 
6&\qquad\quad k=\pi[k]\\ 
7&\qquad \text{if }P[k+1]==P[q]\\ 
8&\qquad\quad k = k+1\\ 
9&\qquad\pi[q] = k\\ 
10&\quad \text{return }\pi\\
\end{aligned}$ 

