# 深度优先遍历

## 递归法

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

### 前序遍历

1. **确定递归函数的参数和返回值**：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：

```cpp
void traversal(TreeNode* cur, vector<int>& vec)
```

2. **确定终止条件**：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：

```cpp
if (cur == NULL) return;
```

3. **确定单层递归的逻辑**：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：

```cpp
vec.push_back(cur->val);    // 中
traversal(cur->left, vec);  // 左
traversal(cur->right, vec); // 右
```

```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

```go
func preorderTraversal(root *TreeNode) (res []int) {
    var traversal func(node *TreeNode)
    traversal = func(node *TreeNode) {
        if node == nil {
            return
        }
        res = append(res,node.Val)
        traversal(node.Left)
        traversal(node.Right)
    }
    traversal(root)
    return res
}
```

### 中序遍历

```cpp
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}
```

### 后序遍历

```cpp
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```

## 迭代

### 前序遍历

前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。 因为这样出栈的时候才是中左右的顺序。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202312311707002.gif" alt="二叉树前序遍历（迭代法）" style="zoom: 67%;" />

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();// 中
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right); // 右（空节点不入栈）
            if (node->left) st.push(node->left); // 左（空节点不入栈）
        }
        return result;
    }
};
```

### 中序遍历

为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作：

1. **处理：将元素放进result数组中**
2. **访问：遍历节点**

分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**

那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

那么**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202312311708607.gif" alt="二叉树中序遍历（迭代法）" style="zoom: 67%;" />

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            // 指针来访问节点，访问到最底层
            if (cur != NULL) { 
                // 将访问的节点放进栈
                st.push(cur); 
                cur = cur->left;// 左
            } else {
                // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                cur = st.top(); 
                st.pop();
                result.push_back(cur->val);// 中
                cur = cur->right;          // 右
            }
        }
        return result;
    }
};
```

### 后序遍历

再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202312311709093.png" alt="前序到后序" style="zoom:50%;" />

**所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：**

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->left) st.push(node->left); 
            // 空节点不入栈
            if (node->right) st.push(node->right); 
        }
        // 将结果反转之后就是左右中的顺序了
        reverse(result.begin(), result.end()); 
        return result;
    }
};
```

# 层序遍历

## 迭代法

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401012121385.gif" alt="102二叉树的层序遍历" style="zoom: 50%;" />

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    Deque<TreeNode> que = new ArrayDeque<>();
    if (root != null){ que.offer(root);};
    while (!que.isEmpty()) {
        int size = que.size();
        List<Integer> tmpRes = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            TreeNode node = que.poll();
            tmpRes.add(node.val);
            if (node.left != null) {
                que.offer(node.left);
            }
            if (node.right != null) {
                que.offer(node.right);
            }
        }
        res.add(tmpRes);
    }
    return res;
}
```

## 递归法

```cpp
# 递归法
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth)
    {
        if (cur == nullptr) return;
        if (result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result, depth + 1);
        order(cur->right, result, depth + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

```java
public void order(TreeNode node, List<List<Integer>>res, int depth){
    if (node ==null){return;}
    if (res.size() < depth){
        res.add(new ArrayList<>());
    }
    res.get(depth-1).add(node.val);
    order(node.left, res, depth+1);
    order(node.right, res, depth+1);
}
// 层序遍历递归法
public List<List<Integer>> levelOrder2(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    order(root, res, 1);
    return res;
}
```

相关题目

- [102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
- [107.二叉树的层次遍历II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)
- [199.二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)
- [637.二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)
- [429.N叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)
- [515.在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)
- [116.填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)
- [117.填充每个节点的下一个右侧节点指针II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)
- [104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
- [111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

# 翻转二叉树

## 递归法

在遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。**这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！** **层序遍历也可以，只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！**

我们下文以前序遍历为例，通过动画来看一下翻转的过程:

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401012124550.gif" alt="翻转二叉树" style="zoom:50%;" />

我们来看一下递归三部曲：

- 确定递归函数的参数和返回值

参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。

返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为`TreeNode*`。

```cpp
TreeNode* invertTree(TreeNode* root)
```

- 确定终止条件

当前节点为空的时候，就返回

```cpp
if (root == NULL) return root;
```

- 确定单层递归的逻辑

因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。

```cpp
swap(root->left, root->right);
invertTree(root->left);
invertTree(root->right);
```

基于这递归三步法，代码基本写完，C++代码如下：

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        swap(root->left, root->right);  // 中
        invertTree(root->left);         // 左
        invertTree(root->right);        // 右
        return root;
    }
```

## 迭代法

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                swap(node->left, node->right);          // 节点处理逻辑
            }
        }
        return root;
    }
};
```

## 拓展

**文中我指的是递归的中序遍历是不行的，因为使用递归的中序遍历，某些节点的左右孩子会翻转两次。**

如果非要使用递归中序的方式写，也可以，如下代码就可以避免节点左右孩子翻转两次的情况：

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        invertTree(root->left);         // 左
        swap(root->left, root->right);  // 中
        invertTree(root->left);         // 注意 这里依然要遍历左孩子，因为中间节点已经翻转了
        return root;
    }
};
```

代码虽然可以，但这毕竟不是真正的递归中序遍历了。

但使用迭代方式统一写法的中序是可以的。

代码如下：

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                st.push(node);                          // 中
                st.push(NULL);
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                swap(node->left, node->right);          // 节点处理逻辑
            }
        }
        return root;
    }
};
```

为什么这个中序就是可以的呢，因为这是用栈来遍历，而不是靠指针来遍历，避免了递归法中翻转了两次的情况，大家可以画图理解一下，这里有点意思的。

# 对称二叉树

[力扣题目链接](https://leetcode.cn/problems/symmetric-tree/)

本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。**正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**

但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。

其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401012132867.png" alt="101. 对称二叉树1" style="zoom: 33%;" />

1. **确定递归函数的参数和返回值**

因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。

返回值自然是bool类型。

```cpp
bool compare(TreeNode* left, TreeNode* right)
```

2. **确定终止条件**

要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。

节点为空的情况有：（**注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点**）

- 左节点为空，右节点不为空，不对称，return false
- 左不为空，右为空，不对称 return false
- 左右都为空，对称，返回true

此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：

- 左右都不为空，比较节点数值，不相同就return false

此时左右节点不为空，且数值也不相同的情况我们也处理了。

```cpp
if (left == NULL && right != NULL) return false;
else if (left != NULL && right == NULL) return false;
else if (left == NULL && right == NULL) return true;
else if (left->val != right->val) return false; // 注意这里我没有使用else
```

注意上面最后一种情况，我没有使用else，而是else if， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。

3. **确定单层递归的逻辑**

此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。

- 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
- 比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。
- 如果左右都对称就返回true ，有一侧不对称就返回false 。

代码如下：

```cpp
bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
bool isSame = outside && inside;          // 左子树：中、 右子树：中（逻辑处理）
return isSame;
```

如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。

```java
public boolean compareSymmetric(TreeNode leftSub,TreeNode rightSub){
    if (leftSub==null && rightSub == null) return true;
    if (leftSub!= null && rightSub ==null) return false;
    if (leftSub== null && rightSub!=null) return false;
    if (leftSub.val!= rightSub.val)return false;
    boolean inside = compareSymmetric(leftSub.right, rightSub.left);
    boolean outside = compareSymmetric(leftSub.left, rightSub.right);
    return inside && outside;
}
public boolean isSymmetric(TreeNode root) {
    if (root == null){return true;}
    return compareSymmetric(root.left,root.right);

}
```

# 二叉树的最大深度

本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。

- 二叉树节点的**深度**：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
- 二叉树节点的**高度**：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）
- 因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）

**而根节点的高度就是二叉树的最大深度**，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401032155440.png" alt="110.平衡二叉树2" style="zoom: 33%;" />

## 后序遍历递归法

```java
public int maxDepth(TreeNode root) {
    return getDepth(root);
}

public int getDepth(TreeNode node){
    if (node == null) return 0;
    int leftDepth = getDepth(node.left);
    int rightDepth = getDepth(node.right);
    return 1 + Math.max(leftDepth, rightDepth);
}
```

## 前序遍历递归法(回溯)

```cpp
class solution {
public:
    int result;
    void getdepth(TreeNode* node, int depth) {
        result = depth > result ? depth : result; // 中

        if (node->left == NULL && node->right == NULL) return ;

        if (node->left) { // 左
            depth++;    // 深度+1
            getdepth(node->left, depth);
            depth--;    // 回溯，深度-1
        }
        if (node->right) { // 右
            depth++;    // 深度+1
            getdepth(node->right, depth);
            depth--;    // 回溯，深度-1
        }
        return ;
    }
    int maxDepth(TreeNode* root) {
        result = 0;
        if (root == NULL) return result;
        getdepth(root, 1);
        return result;
    }
};
```

```java
public int maxdepth = 0;
public int maxDepth2(TreeNode root) {
    getDepth2(root, 1);
    return maxdepth;
}
public void getDepth2(TreeNode node, int depth){
    if (node == null) return;
    maxdepth = Math.max(maxdepth, depth);
    depth ++;
    getDepth2(node.left, depth);
    getDepth2(node.right, depth);
}
```

## 迭代法采用层序遍历

使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401032029259.png" alt="层序遍历" style="zoom:50%;" />

```cpp
class solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

## N叉树

```java
public int maxDepthN(NTreeNode root) {
    if (root==null) return 0;
    int maxDepth = 0;
    for (NTreeNode child: root.children) {
        int childDepth = maxDepthN(child);
        maxDepth = Math.min(maxDepth, childDepth);
    }
    return maxDepth+1;
}
```

```java
public int maxdepth = 0;
public int maxDepth(Node root) {
    getDepth2(root, 1);
    return maxdepth;
}
public void getDepth2(Node node, int depth){
    if (node == null) return;
    maxdepth = Math.max(maxdepth, depth);
    depth ++;
    for (Node child: node.children){
        getDepth2(child, depth);
    }
}
```

# 二叉树最小深度

## 递归法

### 后序遍历

使用后序遍历，其实求的是根节点到叶子节点的最小距离，就是求高度的过程，不过这个最小距离也同样是最小深度。

注意题目中说的是：**最小深度是从根节点到最近叶子节点的最短路径上的节点数量。**注意是**叶子节点**。左右孩子都为空的节点才是叶子节点！

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401032027357.png" alt="111.二叉树的最小深度" style="zoom:33%;" />

```java
public int minDepth(TreeNode root) {
    if (root == null) return 0;
    int leftDepth = minDepth(root.left);
    int rightDepth = minDepth(root.right);
    if (root.left == null && root.right != null) return rightDepth+1;
    if (root.left != null && root.right == null) return leftDepth+1;
    return Math.min(leftDepth,rightDepth)+1;
}
```

### 前序遍历

```java
public int minRes = Integer.MAX_VALUE;
public int minDepth2(TreeNode root) {
    mindeep(root, 1);
    return minRes;
}

public void mindeep(TreeNode node, int depth){
    if (node==null) return;
    if (node.left == null && node.right == null){
        minRes = Math.min(depth, minRes);
    }
    depth ++;
    mindeep(node.left, depth);
    mindeep(node.right,depth);
}
```

## 迭代法(层序遍历)

```java
public int minDepth(TreeNode root) {
    int deep = 0;
    Deque<TreeNode> que = new ArrayDeque<>();
    if (root != null){ que.offer(root);};
    while (!que.isEmpty()) {
        int size = que.size();
        deep++;
        for (int i = 0; i < size; i++) {
            TreeNode node = que.poll();
            if (node.left == null && node.right == null){
                return deep;
            }
            if (node.left != null) {
                que.offer(node.left);
            }
            if (node.right != null) {
                que.offer(node.right);
            }
        }
    }
    return deep;
}
```

# 完全二叉树节点的数量

[力扣题目链接](https://leetcode.cn/problems/count-complete-tree-nodes/)

## 当做普通二叉树

### 递归-后序遍历

```cpp
// 版本一
class Solution {
private:
    int getNodesNum(TreeNode* cur) {
        if (cur == NULL) return 0;
        int leftNum = getNodesNum(cur->left);      // 左
        int rightNum = getNodesNum(cur->right);    // 右
        int treeNum = leftNum + rightNum + 1;      // 中
        return treeNum;
    }
public:
    int countNodes(TreeNode* root) {
        return getNodesNum(root);
    }
};
```

```cpp
// 版本二
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == NULL) return 0;
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};
//时间复杂度：O(n)
//空间复杂度：O(log n)，算上了递归系统栈占用的空间
```

### 迭代-层序遍历

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int result = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                result++;   // 记录节点数量
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

## 完全二叉树

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

完全二叉树只有两种情况

- 就是满二叉树
  - 可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。
- 最后一层叶子节点没有满。
  - 分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401032118109.png" alt="222.完全二叉树的节点个数" style="zoom: 33%;" />

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401032118322.png" alt="222.完全二叉树的节点个数1" style="zoom: 33%;" />

可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。

这里关键在于如何去判断一个左子树或者右子树是不是满二叉树呢？

在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树。如图：

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401032119496.png" alt="img" style="zoom:33%;" />

在完全二叉树中，如果递归向左遍历的深度不等于递归向右遍历的深度，则说明不是满二叉树，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163709.png" alt="img" style="zoom:33%;" />

那有录友说了，这种情况，递归向左遍历的深度等于递归向右遍历的深度，但也不是满二叉树，如题：<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401032120004.png" alt="img" style="zoom:33%;" />

如果这么想，大家就是对 完全二叉树理解有误区了，**以上这棵二叉树，它根本就不是一个完全二叉树**！

判断其子树是不是满二叉树，如果是则利用公式计算这个子树（满二叉树）的节点数量，如果不是则继续递归，那么 在递归三部曲中，第二部：终止条件的写法应该是这样的：

```java
public int countNodes(TreeNode root) {
    if (root == null) return 0;
    TreeNode left = root.left;
    TreeNode right = root.right;
    int leftDepth = 0, rightDepth = 0; 
    // 这里初始为0是有目的的，为了下面求指数方便
    while (left != null) {  // 求左子树深度
        left = left.left;
        leftDepth++;
    }
    while (right != null) { // 求右子树深度
        right = right.right;
        rightDepth++;
    }
    if (leftDepth == rightDepth) {
        return (2 << leftDepth) - 1; 
        // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
    }
    return countNodes(root.left) + countNodes(root.right) + 1;
}
```

# 平衡二叉树

[力扣题目链接](https://leetcode.cn/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

此时大家应该明白了既然要求比较高度，必然是要后序遍历。

1. 明确递归函数的参数和返回值

	参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。

	那么如何标记左右子树是否差值大于1呢？如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。


```cpp
// -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度
int getHeight(TreeNode* node)
```

2. 明确终止条件

	递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0

```cpp
if (node == NULL) {
    return 0;
}
```

3. 明确单层递归的逻辑

	如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。


```cpp
int leftHeight = getHeight(node->left); // 左
if (leftHeight == -1) return -1;
int rightHeight = getHeight(node->right); // 右
if (rightHeight == -1) return -1;

int result;
if (abs(leftHeight - rightHeight) > 1) {  // 中
    result = -1;
} else {
    result = 1 + max(leftHeight, rightHeight); // 以当前节点为根节点的树的最大高度
}

return result;
```

代码精简之后如下：

```cpp
int leftHeight = getHeight(node->left);
if (leftHeight == -1) return -1;
int rightHeight = getHeight(node->right);
if (rightHeight == -1) return -1;
return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
```

此时递归的函数就已经写出来了，这个递归的函数传入节点指针，返回以该节点为根节点的二叉树的高度，如果不是二叉平衡树，则返回-1。
	
getHeight整体代码如下：

```cpp
int getHeight(TreeNode* node) {
    if (node == NULL) {
        return 0;
    }
    int leftHeight = getHeight(node->left);
    if (leftHeight == -1) return -1;
    int rightHeight = getHeight(node->right);
    if (rightHeight == -1) return -1;
    return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
}
```

最后本题整体递归代码如下：

```cpp
class Solution {
public:
    // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
    int getHeight(TreeNode* node) {
        if (node == NULL) {
            return 0;
        }
        int leftHeight = getHeight(node->left);
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(node->right);
        if (rightHeight == -1) return -1;
        return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;
    }
};
```

```java
public boolean isBalanced(TreeNode root) {
    return getHeight(root) != -1;
}

private int getHeight(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftHeight = getHeight(root.left);
    if (leftHeight == -1) {
        return -1;
    }
    int rightHeight = getHeight(root.right);
    if (rightHeight == -1) {
        return -1;
    }
    // 左右子树高度差大于1，return -1表示已经不是平衡树了
    if (Math.abs(leftHeight - rightHeight) > 1) {
        return -1;
    }
    return Math.max(leftHeight, rightHeight) + 1;
}
```

# 二叉树的所有路径

给定一个二叉树，返回所有从根节点到叶子节点的路径。

## 递归与回溯

这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。前序遍历以及回溯的过程如图：

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401032303883.png" alt="257.二叉树的所有路径" style="zoom:50%;" />

我们先使用递归的方式，来做前序遍历。**要知道递归和回溯就是一家的，本题也需要回溯。**

```java
public List<String> binaryTreePaths(TreeNode root) {
    List<Integer> path = new ArrayList<>();
    List<String> res = new ArrayList<>();
    travel(root, path, res);
    return res;
}

public void travel(TreeNode node, List<Integer> path, List<String> res){
    path.add(node.val);
    if(node.left == null && node.right==null) {
        StringBuffer r = new StringBuffer();
        for(int n: path){
            r.append(n);
            r.append("->");
        }
        r.deleteCharAt(r.length()-1);
        r.deleteCharAt(r.length()-1);
        res.add(r.toString());
        return;
    }
    if (node.left != null){
        travel(node.left, path, res);
        path.remove(path.size()-1);
    }
    if (node.right != null){
        travel(node.right, path, res);
        path.remove(path.size()-1);
    }
}
// 方法二(精简版)
List<String> result = new ArrayList<>();

public List<String> binaryTreePaths(TreeNode root) {
    deal(root, "");
    return result;
}

public void deal(TreeNode node, String s) {
    if (node == null)
        return;
    if (node.left == null && node.right == null) {
        result.add(new StringBuilder(s).append(node.val).toString());
        return;
    }
    String tmp = new StringBuilder(s).append(node.val).append("->").toString();
    deal(node.left, tmp);
    deal(node.right, tmp);
}
```

```cpp
// 方法二(精简版)
class Solution {
    private:

    void traversal(TreeNode* cur, string path, vector<string>& result) {
        path += to_string(cur->val); // 中
        if (cur->left == NULL && cur->right == NULL) {
            result.push_back(path);
            return;
        }
        if (cur->left) traversal(cur->left, path + "->", result); // 左
        if (cur->right) traversal(cur->right, path + "->", result); // 右
    }

    public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        string path;
        if (root == NULL) return result;
        traversal(root, path, result);
        return result;

    }
```

如上代码精简了不少，也隐藏了不少东西。

注意在函数定义的时候`void traversal(TreeNode* cur, string path, vector<string>& result)` ，定义的是`string path`，每次都是复制赋值，不用使用引用，否则就无法做到回溯的效果。（这里涉及到C++语法知识）

那么在如上代码中，**貌似没有看到回溯的逻辑，其实不然，回溯就隐藏在`traversal(cur->left, path + "->", result);`中的 `path + "->"`。** 每次函数调用完，path依然是没有加上"->" 的，这就是回溯了。

## 迭代法

```cpp
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        stack<TreeNode*> treeSt;// 保存树的遍历节点
        stack<string> pathSt;   // 保存遍历路径的节点
        vector<string> result;  // 保存最终路径集合
        if (root == NULL) return result;
        treeSt.push(root);
        pathSt.push(to_string(root->val));
        while (!treeSt.empty()) {
            TreeNode* node = treeSt.top(); treeSt.pop(); // 取出节点 中
            string path = pathSt.top();pathSt.pop();    
            // 取出该节点对应的路径
            if (node->left == NULL && node->right == NULL) { // 遇到叶子节点
                result.push_back(path);
            }
            if (node->right) { // 右
                treeSt.push(node->right);
                pathSt.push(path + "->" + to_string(node->right->val));
            }
            if (node->left) { // 左
                treeSt.push(node->left);
                pathSt.push(path + "->" + to_string(node->left->val));
            }
        }
        return result;
    }
};
```

当然，使用java的同学，可以直接定义一个成员变量为object的栈`Stack<Object> stack = new Stack<>();`，这样就不用定义两个栈了，都放到一个栈里就可以了。

```java
class Solution {
    /**
     * 迭代法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        if (root == null)
            return result;
        Stack<Object> stack = new Stack<>();
        // 节点和路径同时入栈
        stack.push(root);
        stack.push(root.val + "");
        while (!stack.isEmpty()) {
            // 节点和路径同时出栈
            String path = (String) stack.pop();
            TreeNode node = (TreeNode) stack.pop();
            // 若找到叶子节点
            if (node.left == null && node.right == null) {
                result.add(path);
            }
            //右子节点不为空
            if (node.right != null) {
                stack.push(node.right);
                stack.push(path + "->" + node.right.val);
            }
            //左子节点不为空
            if (node.left != null) {
                stack.push(node.left);
                stack.push(path + "->" + node.left.val);
            }
        }
        return result;
    }
}
```

# 路径总和

[力扣题目链接](https://leetcode.cn/problems/path-sum/)

可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树

***确定递归函数的参数和返回类型***

参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。

再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

- 如果需要**搜索整棵二叉树**且不用处理递归返回值，递归函数就不要返回值。（113.路径总和ii）
- 如果需要**搜索整棵二叉树**且需要处理递归返回值，递归函数就需要返回值。 （[236. 二叉树的最近公共祖先 (opens new window)](https://programmercarl.com/0236.二叉树的最近公共祖先.html)）
- 如果要**搜索其中一条符合条件的路径**，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401101508825.png" alt="112.路径总和" style="zoom: 33%;" />

图中可以看出，**遍历的路线，并不要遍历整棵树**，所以递归函数需要返回值，可以用bool类型表示。

```cpp
bool traversal(treenode* cur, int count)   // 注意函数的返回类型
```

***确定终止条件***

不要去累加计数器然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。

如果最后count == 0，同时到了叶子节点的话，说明找到了目标和。

如果遍历到了叶子节点，count不为0，就是没找到。

```cpp
if (!cur->left && !cur->right && count == 0) return true; // 遇到叶子节点，并且计数为0
if (!cur->left && !cur->right) return false; // 遇到叶子节点而没有找到合适的边，直接返回
```

***确定单层递归的逻辑***

因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。

```cpp
if (cur->left) { // 左 （空节点不遍历）
    // 遇到叶子节点返回true，则直接返回true
    if (traversal(cur->left, count - cur->left->val)) return true; // 注意这里有回溯的逻辑
}
if (cur->right) { // 右 （空节点不遍历）
    // 遇到叶子节点返回true，则直接返回true
    if (traversal(cur->right, count - cur->right->val)) return true; // 注意这里有回溯的逻辑
}
return false;
```

以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢。回溯隐藏在`traversal(cur->left, count - cur->left->val)`这里， 因为把`count - cur->left->val` 直接作为参数传进去，函数结束，count的数值没有改变。为了把回溯的过程体现出来，可以改为如下代码：

```cpp
if (cur->left) { // 左
    count -= cur->left->val; // 递归，处理节点;
    if (traversal(cur->left, count)) return true;
    count += cur->left->val; // 回溯，撤销处理结果
}
if (cur->right) { // 右
    count -= cur->right->val;
    if (traversal(cur->right, count)) return true;
    count += cur->right->val;
}
return false;
```

整体代码如下：

```cpp
class Solution {
private:
    bool traversal(TreeNode* cur, int count) {
        if (!cur->left && !cur->right && count == 0) return true; // 遇到叶子节点，并且计数为0
        if (!cur->left && !cur->right) return false; // 遇到叶子节点直接返回

        if (cur->left) { // 左
            count -= cur->left->val; // 递归，处理节点;
            if (traversal(cur->left, count)) return true;
            count += cur->left->val; // 回溯，撤销处理结果
        }
        if (cur->right) { // 右
            count -= cur->right->val; // 递归，处理节点;
            if (traversal(cur->right, count)) return true;
            count += cur->right->val; // 回溯，撤销处理结果
        }
        return false;
    }

public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (root == NULL) return false;
        return traversal(root, sum - root->val);
    }
};
```

以上代码精简之后如下：

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (!root) return false;
        if (!root->left && !root->right && sum == root->val) {
            return true;
        }
        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);
    }
};
```

# 二叉搜索树中的搜索

[二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

二叉搜索树是一个有序树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树

![img](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401182114061.jpeg)

```go
func searchBST(root *TreeNode, val int) *TreeNode {
    if root == nil{
        return nil
    }
    if root.Val == val{
        return root
    }
    var node *TreeNode
    if root.Val > val{
        node = searchBST(root.Right, val)
    }else if root.Val < val{
        node = searchBST(root.Left, val)
    }
    return node
}
```

```cpp
TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            if (root->val > val) root = root->left;
            else if (root->val < val) root = root->right;
            else return root;
        }
        return NULL;
    }
```

**不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了**。**我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点**。例如： [10,5,15,null,null,6,20] 这个case：

![二叉搜索树](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000824.png)

节点10大于左节点5，小于右节点15，但右子树里出现了一个6 这就不符合了！

样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。

此时可以初始化比较元素为longlong的最小值。

问题可以进一步演进：如果样例中根节点的val 可能是longlong的最小值 又要怎么办呢？

```go
func isValidBST2(root *TreeNode) bool {
	var pre *TreeNode
	var check func(node *TreeNode) bool

	check = func(node *TreeNode) bool {
		if node == nil {
			return true
		}
		left := check(node.Left)
		if pre != nil && pre.Val >= node.Val {
			return false
		}
		pre = node
		right := check(node.Right)
		return left && right
	}
	return check(root)
}
```



# 二叉搜索树的最小绝对差

**注意是二叉搜索树**，二叉搜索树可是有序的。遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。

## 递归

那么二叉搜索树采用中序遍历，其实就是一个有序数组。**在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。**最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。

```cpp
class Solution {
private:
vector<int> vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    vec.push_back(root->val); // 将二叉搜索树转换为有序数组
    traversal(root->right);
}
public:
    int getMinimumDifference(TreeNode* root) {
        vec.clear();
        traversal(root);
        if (vec.size() < 2) return 0;
        int result = INT_MAX;
        for (int i = 1; i < vec.size(); i++) { // 统计有序数组的最小差值
            result = min(result, vec[i] - vec[i-1]);
        }
        return result;
    }
};
```

其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。需要用一个pre节点记录一下cur节点的前一个节点。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401192045576.png" alt="530.二叉搜索树的最小绝对差" style="zoom:50%;" />

```java
public int minDiffRes = Integer.MAX_VALUE;
    public TreeNode pre = null;
    public int getMinimumDifference(TreeNode root) {
        if (root == null) return minDiffRes;
        getMinimumDifference(root.left);
        if (pre != null && root.val - pre.val < minDiffRes) {
            minDiffRes =  root.val - pre.val;
        }
        pre = root;
        getMinimumDifference(root.right);
        return minDiffRes;
    }
```

# 二叉搜索树中的众数

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

如果不是二叉搜索树，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。

```cpp
class Solution {
private:

void searchBST(TreeNode* cur, unordered_map<int, int>& map) { // 前序遍历
    if (cur == NULL) return ;
    map[cur->val]++; // 统计元素频率
    searchBST(cur->left, map);
    searchBST(cur->right, map);
    return ;
}
bool static cmp (const pair<int, int>& a, const pair<int, int>& b) {
    return a.second > b.second;
}
public:
    vector<int> findMode(TreeNode* root) {
        unordered_map<int, int> map; // key:元素，value:出现频率
        vector<int> result;
        if (root == NULL) return result;
        searchBST(root, map);
        vector<pair<int, int>> vec(map.begin(), map.end());
        sort(vec.begin(), vec.end(), cmp); // 给频率排个序
        result.push_back(vec[0].first);
        for (int i = 1; i < vec.size(); i++) {
            // 取最高的放到result数组中
            if (vec[i].second == vec[0].second) result.push_back(vec[i].first);
            else break;
        }
        return result;
    }
};
```

**既然是搜索树，它中序遍历就是有序的**。遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。

此时又有问题了，因为要求最大频率的元素集合（注意是集合，不是一个元素，可以有多个众数），如果是数组上大家一般怎么办？

应该是先遍历一遍数组，找出最大频率（maxCount），然后再重新遍历一遍数组把出现频率为maxCount的元素放进集合。（因为众数有多个）

这种方式遍历了两遍数组。

那么我们遍历两遍二叉搜索树，把众数集合算出来也是可以的。

但这里其实只需要遍历一次就可以找到所有的众数。

那么如何只遍历一遍呢？

如果 频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中（以下代码为result数组）。

是不是感觉这里有问题，result怎么能轻易就把元素放进去了呢，万一，这个maxCount此时还不是真正最大频率呢。

所以下面要做如下操作：

频率count 大于 maxCount的时候，不仅要更新maxCount，而且要清空结果集（以下代码为result数组），因为结果集之前的元素都失效了。

```java
int maxModeCount = 0;
    int modeCount = 0;
    List<Integer> modeRes= new ArrayList<>();
    TreeNode preMode = null;
    public int[] findMode(TreeNode root) {
        findModeTravel(root);
        int[] res = new int[modeRes.size()];
        for (int i =0 ;i<=modeRes.size()-1;i++) {
            res[i] = modeRes.get(i);
        }
        return res;
    }
    public void findModeTravel(TreeNode node){
        if (node == null) return;
        findModeTravel(node.left);
        if (preMode != null && preMode.val == node.val){
            modeCount += 1;
        }else{
            modeCount = 1;
        }
        if (modeCount==maxModeCount){
            modeRes.add(node.val);
        }
        if (modeCount > maxModeCount){
            modeRes.clear();
            maxModeCount = modeCount;
            modeRes.add(node.val);
        }
        preMode = node;
        findModeTravel(node.right);
    }
```

# 二叉树的最近公共祖先

[力扣题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

## 思路

遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。那么二叉树如何可以自底向上查找呢？**回溯**啊，二叉树回溯的过程就是从低到上。**后序遍历（左右中）就是天然的回溯过程**，可以根据左右子树的返回值，来处理中节点的逻辑。

如何判断一个节点是节点q和节点p的公共祖先呢。**情况一：找到一个节点，其左子树出现结点p，右子树出现节点q，或者左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。**

判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。（题目强调：**二叉树节点数值是不重复的，而且一定存在 q 和 p**。）

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401222051849.png" alt="img" style="zoom:33%;" />



**情况二：节点本身p(q)，它拥有一个子孙节点q(p)。**其实情况一 和 情况二 代码实现过程都是一样的，也可以说，实现情况一的逻辑，顺便包含了情况二。因为遇到 q 或者 p 就返回，这样也包含了 q 或者 p 本身就是 公共祖先的情况。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401222053966.png" alt="img" style="zoom:33%;" />

值得注意的是 本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点。但事实上还要遍历根节点右子树（即使此时已经找到了目标节点了），也就是图中的节点4、15、20。因为在如下代码的后序遍历中，如果想利用left和right做逻辑处理， 不能立刻返回，而是要等left与right逻辑处理完之后才能返回。

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401222056497.png" alt="236.二叉树的最近公共祖先2" style="zoom:33%;" />

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if(left != null && right == null) return left;
    if(left == null && right != null) return right;
    if (left != null && right != null) return root;
    return null;
}
```

# 二叉搜索树的最近公共祖先

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202401222104146.png" alt="235.二叉搜索树的最近公共祖先" style="zoom:50%;" />

因为是有序树，所有 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在 [p, q]区间的。即中节点 > p && 中节点 < q 或者 中节点 > q && 中节点 < p。

那么只要从上到下去遍历，遇到 cur节点是数值在[p, q]区间中则一定可以说明该节点cur就是p 和 q的公共祖先。 那问题来了，**一定是最近公共祖先吗**？如果 从节点5继续向左遍历，那么将错过成为p的祖先， 如果从节点5继续向右遍历则错过成为q的祖先。所以当我们从上向下去递归遍历，第一次遇到 cur节点是数值在[q, p]区间中，那么cur就是 q和p的最近公共祖先。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220926165141.png" alt="235.二叉搜索树的最近公共祖先2" style="zoom: 50%;" />

可以看出直接按照指定的方向，就可以找到节点8，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！

```cpp
class Solution {
private:
    TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q) {
        if (cur == NULL) return cur;
                                                        // 中
        if (cur->val > p->val && cur->val > q->val) {   // 左
            TreeNode* left = traversal(cur->left, p, q);
            if (left != NULL) {
                return left;
            }
        }

        if (cur->val < p->val && cur->val < q->val) {   // 右
            TreeNode* right = traversal(cur->right, p, q);
            if (right != NULL) {
                return right;
            }
        }
        return cur;
    }
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return traversal(root, p, q);
    }
};
```

精简后：

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root->val > p->val && root->val > q->val) {
            return lowestCommonAncestor(root->left, p, q);
        } else if (root->val < p->val && root->val < q->val) {
            return lowestCommonAncestor(root->right, p, q);
        } else return root;
    }
};
```

迭代法：

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while(root) {
            if (root->val > p->val && root->val > q->val) {
                root = root->left;
            } else if (root->val < p->val && root->val < q->val) {
                root = root->right;
            } else return root;
        }
        return NULL;
    }
};
```

# 删除二叉搜索树中的节点

[删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

- 第一种情况：没找到删除的节点，遍历到空节点直接返回了

- 找到删除的节点

  - 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
  - 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
  - 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
  - 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。

  ![450.删除二叉搜索树中的节点](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402192114695.gif)

```
if root == nil {
		return nil
	}
	if root.Val > key {
		root.Left = deleteNode(root.Left, key)
		return root
	}
	if root.Val < key{
		root.Right = deleteNode(root.Right, key)
		return root
	}
	if root.Left == nil {
		return root.Right
	}
	if root.Right == nil{
		return root.Left
	}
	move := func (){
		node := root.Right
        fmt.Printf("node: %d", node.Val)
		for node.Left != nil{
			node = node.Left
		}
		node.Left = root.Left
	}
	move()
	return root.Right;
```

# 修建二叉树

[ 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

发现节点0并不符合区间要求，那么将节点0的右孩子 节点2 直接赋给 节点3的左孩子就可以了（就是把节点0从二叉树中移除）

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202402192127580.png" alt="669.修剪二叉搜索树1" style="zoom:33%;" />

要遍历整棵树，做修改，其实不需要返回值也可以，我们也可以完成修剪（其实就是从二叉树中移除节点）的操作。**但是有返回值，更方便，可以通过递归函数的返回值来移除节点。**

```go
func trimBST(root *TreeNode, low int, high int) *TreeNode {
    if root == nil{
        return nil
    }
    if root.Val < low{
        return trimBST(root.Right, low, high)
    }
    if root.Val > high{
        return trimBST(root.Left, low, high)
    }
    root.Left = trimBST(root.Left, low, high)
    root.Right = trimBST(root.Right, low, high)
    return root
}
```

这多余的节点究竟是如何从二叉树中移除的呢？

如下代码相当于把节点0的右孩子（节点2）返回给上一层，

```go
if root.Val < low{
    return trimBST(root.Right, low, high)
}
```

然后如下代码相当于用节点3的左孩子 把下一层返回的 节点0的右孩子（节点2） 接住。

```go
root.Right = trimBST(root.Right, low, high)
```
