# b树

## 用途

常用的计算机存储介质分为**内存 memory** (全称 main memory) 和**磁盘 disk** (又称外存 external memory)：

- 内存**速度快**，但价格昂贵，容量有限，且属于数据易失性存储介质（设备断电时，数据会丢失）；
- 磁盘**速度慢**，但价格便宜，容量充足，且能保证数据持久化稳定存储。

访问一次内存的耗时大约为 100 ns 的量级，而访问一次磁盘的耗时可能处在 10 ms 的量级，两者之间的速度差距达到 10万倍。

因此，提升性能的关键点很大程度上在于**减少访问磁盘的 io 次数**。 这个过程中也需要**结合局部性原理**的应用，尽可能把需要用到的**热数据缓存在内存**中加以复用。

类似 b 树这样的**多叉搜索树数据结构**，很**适用于作为读密集型数据库或文件系统的索引模型**。 虽然在写流程中，对索引结构的调整存在一定代价，但是在读流程中，**每与索引的一次交互对应一次磁盘 io**，**检索进度也会因此向下递进一层**，最坏的情况下在来到叶子节点时也必然会得到检索结果。由于 **b 树形状扁平，高度很低**，因此对应的**磁盘 io 次数也会很少**。

![图片](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404101052725.png)

## 定义

b 树，英文名为 b-tree，很多人也把其称为 b-(jiǎn)树。 b 树是一种**自平衡的多叉搜索树**，通过维护有序的数据结构，保证能够**基于对数级别的时间复杂度完成搜索、插入和删除操作.**

下面是详细定义：

b 树是一种平衡多叉搜索树，每个 b 树实例都有一个**阶数**的概念，针对于一棵 **n 阶 b 树**，需要满足：

- 所有**叶子节点处在相同的层级**，即从根节点出发到底端的各条路径高度一致；
- 每个父节点**最多只有 n 个子节点**，且父节点内元素个数为子节点数 - 1；
- 除了根节点外的父节点，**至少拥有 [n/2] 个子节点**（"[]" 表示向上取整）；
- 倘若根节点存在子节点，则至少拥有 2 个子节点；

> b 树可视化—— https://www.cs.usfca.edu/~galles/visualization/BTree.html

一棵 4 阶 b 树的示意图如下所示：

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404101103125.webp" alt="图片" style="zoom:50%;" />

在基础定义之上，再针对其中涉及到的几个核心概念展开说明：

- 阶数 n

> - 限定了 b 树中父节点的**最大子节点个数**；
> - 并限定了除根节点外，其它父节点的**子节点个数的下限**(>= [n/2])；
> - 因此，阶数和 b 树的扁平化程度正相关，**阶数越高**，b 树**横向拓展性越好**，同等数据量下高度就越低，而**单个节点内存储的数据量就越多**。

通过下方的示意图能看到，【10,12,14】节点正好达到了阶数 4 的上限，其拥有的子节点数 量恰好为 4 个，如果再多的话就需要调整处理了。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404101107211.webp" alt="图片" style="zoom: 50%;" />

- 根节点：

> - b 树的起点，拥有的子节点数量**上限**同样受到阶数的限制 <= 阶数 n。
> - 但根节点的子节点数量**下限**比较特殊:
>   - 如果根节点同时为叶子节点，则子节点数可以为 0，此时整棵 b 树只有一个节点；
>   - 如果根节点拥有子节点数，那么子节点个数至少为 2。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404101121341.webp" alt="图片" style="zoom:50%;" />

-  内部节点

> - 除根节点外拥有子节点的父节点. 
> - 拥有的子节点数量上限同样受到阶数的 <= 阶数 n，且拥有子节点的数量 >= [n/2] ). 
> - 又由于父节点 key 个数为子节点树 - 1，因此可以总结如下：
>   - 内部节点的子节点数量 x 满足： **[n/2] <= x <= n**
>   - 内部节点的元素数量 x 满足：**[n/2] - 1 <= x <= n - 1**

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404101128031.webp" alt="图片" style="zoom:50%;" />

-  叶子节点

> -  不存在子节点的最底层节点，处于同一层级。
> -  叶子节点的元素数量限制为：
>   - 叶子节点子节点数量 x 满足：**x = 0**
>   - 叶子节点元素数量 x 满足：**[n/2] - 1 <= x <= n - 1**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/3ic3aBqT2ibZvW68Sy9GmwDdiaJdgGJ5Y3nccHVKaxcww9IGYwgAvuib3ic1ul9zn7dn4wPaDaPzEpVDQhE99X4VHUQ/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 元素插入

首先针对 **b 树的元素插入流程**，核心步骤如下：

- step1：根据元素找到其应该从属的叶子节点；
- step2：在叶子节点合适位置中插入元素；
- step3：倘若插入后叶子元素数量 <= 阶数 n，直接结束流程；
- step4：倘若插入后叶子元素数量 > 阶数 n，则**沿中间元素将节点分裂两个节点，并将中间节点上升插入到父节点中。**

上述 step4 的步骤称之为 “**spill**”，它可能进一步引起**父节点元素数量超限**，因此会针对父节点递归执行 step4. 最坏的情况下，可能一直分裂到根节点，最终生成新的根节点实例，导致 b 树整体高度加 1.

 

下面是针对一棵 3 阶 b 树的元素插入案例：

- moment1：原本 b 树中已存在元素【1,2,3,4,5,6】，此时拟在节点【5,6】中插入一个新的元素7；

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404101413236.webp" alt="图片" style="zoom: 33%;" />

- moment2：插入元素 7 后，节点【5,6,7】元素数量 > 阶数 - 1，因此沿中间元素 6 进行 split，拆分成 【5】和 【7】两个独立节点，并把元素 6 追加到父节点中，形成新的父节点结构：【2,4,6】

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404101414816.webp" alt="图片" style="zoom: 33%;" />

- moment3：此时父节点【2,4,6】的元素数量 > 阶数 - 1，因此沿中间元素 4 进行 split，拆分成 【2】和 【6】两个独立节点，并对元素 4 进行上升，因为不存在父节点，因此构造出一个新的父节点【4】，至此，spill 流程结束，整棵 b 树高度加 1

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404101416043.webp" alt="图片" style="zoom: 33%;" />



## 元素删除

下面针对 **b 树的元素删除流程**进行梳理，这一块儿相对复杂一些，核心步骤如下：

- step1：根据元素找到从属的叶子节点；
- step2：在叶子节点中删除对应元素；
- step3：如果被删除数据是处在某个父节点中的索引结构，其原本关联了左右子节点，则转移其中一个子节点中最相近的元素到父节点被删除元素的位置；如果没有左右子节点，则忽略本步骤；
- step4：查看此时是否存在节点元素数量**不满足 >= [n/2] - 1** 的条件， 如果没有，则结束流程，否则需要先查看其相邻兄弟节点的数据状况；
- step5：如果有相邻兄弟节点比较丰满（数据条数 > [n/2] - 1），则向父节点**借一个最相近**的元素填补被删除元素所在位置，再从丰满兄弟节点处借一笔相近数据填充到父节点被借走元素的所在位置
- step6：如果相邻兄弟节点都比较消瘦（数据条数 <= [n/2] - 1），则和相邻兄弟节点以及父节点被覆盖到的局部元素 "**合并**" 成一个新的节点.

**step4-step6 的流程称之为“rebalance”.** 如果执行到 step6 ，则需要**检查父节点状况是否满足条件，如果不满足，则以父节点为起点沿 step4 开始递归执行。** 最不利的情况可能层层向上递归合并，最终 b 树的整体高度可能会下降。

 

下面是针对一棵 5 阶 b 树的元素删除案例：

- moment1：原本 b 树中已存在元素【1,3,4,5,6,7,9,10,11,12,13,15,16,17,18,19,20,22,23,24】，此时拟在节点【18,19】中删除元素——19

![图片](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404101424360.webp)

 

- moment2：删除 19 后，节点【18】不满足 >= [n/2] - 1 的数量下限，于是查看相邻兄弟节点的数据状况，发现兄弟节点【22,23,24】比较丰满，数据量 > [n/2] - 1. 接下来，从父节点中借来元素 20，节点【18】-> 【18,20】，满足数量下限，再从兄弟节点中借来元素 22，父节点【17,20】-> 【17,22】. 至此，一轮 rebalance 流程结束，所有节点数据均满足条件.

![图片](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404101425126.webp)

 

- moment3：在 moment2 的基础上，进一步尝试从节点【1,3】中删除元素 3

![图片](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404101426901.webp)

 

- moment4：删除 3 后，节点【1】不满足 >= [n/2] - 1 的数量下限，紧接着查看相邻兄弟节点的数据状况，发现没有丰满的兄弟节点. 于是节点【1】、消瘦兄弟节点【5,6】以及父节点局部数据范围【4】进行合并，生成新节点【1,4,5,6】

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/3ic3aBqT2ibZvW68Sy9GmwDdiaJdgGJ5Y3nfibjxYMbYM3W2Olt6faT04GIdmyoicmhORibga9MvRsEUs1DhTGjjdwCQ/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

- moment5：然而父节点【7】不满足 >= [n/2] - 1 的数量下限，查看相邻兄弟节点【17,22】发现也是消瘦的类型，于是重复合并规则，将子节点【7】、兄弟节点【17,22】和父节点【13】合并到一起，形成一个新节点【7,13,17,22】. 至此 reblance 流程结束，b 树整体高度减 1

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/3ic3aBqT2ibZvW68Sy9GmwDdiaJdgGJ5Y3nEdCKfp16Q3hO7t3tpBgGkSdWJicYf6WsX6Qibfplf4bo3VqwBy0kRblw/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

#  b+树

## 定义

b+树继承了 b 树的绝大多数特性，并在基础上作了几点调整：

- **全量数据均存放于叶子节点，非叶子节点只作索引**；
- 在父节点中，每处元素会冗余其**右子树中的最小元素作为索引值**；
- **叶子节点彼此间通过指针串联形成有序的单向链表**。

 

下面给出一个 **3 阶 b+ 树**示意图，展示如下：

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404101429670.webp" alt="图片" style="zoom:50%;" />

> b+ 树可视化—— https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html

 

## 对比b树

我们通常认为，b+ 树相比于 b 树更加适合于用于作为读密集型数据库的索引结构，其原因就在于：

- **更高效的性能：** 性能瓶颈取决于磁盘 io 的次数。由于 b+ 树所有非叶子节点只存放索引信息，不存放实际数据，这使得**相同的节点大小之下，能存放的索引信息更多**，进一步使得 b+ 树相比于 b 树形状**更扁平**，高度更低，因此**磁盘 io 次数更少**，对应性能表现就更好；
- **更稳定的性能：** 因为 b+ 树全量数据存储于叶子节点，因此每次读流程都需要走到底部的叶子节点处，**磁盘 io 次数固定**，相对 b 树更加稳定；
- **更适合范围检索：** 因为 b+ 树全量数据存储于叶子节点，且建立成**单向有序链表**结构，因此**更利于范围查询操作**。****