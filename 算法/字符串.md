# KMP

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

## 前缀表

**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**

要在**文本串**：aabaabaafa 中查找是否出现过一个**模式串**：aabaaf。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404072002982.gif" alt="KMP详解1" style="zoom: 80%;" />

可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。

但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。

**前缀表是如何记录的呢？**

首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。

那么什么是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

##  最长公共(相等)前后缀

文章中字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**。**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。

> 那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？
>
> 我查了一遍 算法导论 和 算法4里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。
>
> **因为前缀表要求的就是相同前后缀的长度。**
>
> 而最长公共前后缀里面的“公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。

所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等.....。

## 为什么一定要用前缀表

回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图：

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404072006101.png" alt="KMP精讲1" style="zoom:50%;" />

然后就找到了下标2，指向b，继续匹配：如图

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404072006808.png" alt="KMP精讲2" style="zoom:50%;" />

下标5之前这部分的字符串（也就是字符串aabaa）的**最长相等的前缀 和 后缀字符串是 子字符串aa ，**因为找到了最长相等的前缀和后缀，**匹配失败的位置是后缀子串的后面**，那么我们找到与其相同的前缀的后面重新匹配就可以了。

所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。

## 如何计算前缀表

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404072008008.png" alt="KMP精讲5" style="zoom:50%;" />

长度为前1个字符的子串`a`，最长相同前后缀的长度为0。（注意字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**；**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。）

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404072010620.png" alt="KMP精讲6" style="zoom: 50%;" />

长度为前2个字符的子串`aa`，最长相同前后缀的长度为1。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404072010853.png" alt="KMP精讲7" style="zoom: 50%;" />

长度为前3个字符的子串`aab`，最长相同前后缀的长度为0。

以此类推： 长度为前4个字符的子串`aaba`，最长相同前后缀的长度为1。 长度为前5个字符的子串`aabaa`，最长相同前后缀的长度为2。 长度为前6个字符的子串`aabaaf`，最长相同前后缀的长度为0。

那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图：

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404072011414.png" alt="KMP精讲8" style="zoom: 50%;" />

可以看出模式串与前缀表对应位置的数字表示的就是：**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

![KMP精讲2](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404072011327.gif)

找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。

为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。

所以要看前一位的 前缀表的数值。

前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。

最后就在文本串中找到了和模式串匹配的子串了。

## 前缀表与next数组

很多KMP算法的实现都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？

next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。

为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。

其实**这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**

后面我会提供两种不同的实现代码，大家就明白了。

## 使用next数组来匹配

**以下我们以前缀表统一减一之后的next数组来做演示**。

有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。

注意next数组是新前缀表（旧前缀表统一减一了）。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/202404072016151.gif" alt="KMP精讲4" style="zoom: 67%;" />

## 时间复杂度分析

其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。

暴力的解法显而易见是O(n × m)，所以**KMP在字符串匹配中极大地提高了搜索的效率。**
