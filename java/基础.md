# 关键字

**标识符和关键字的区别**

- **标识符** 就是为程序、类、变量、方法等取的名字。
- **关键字**是被java中赋予特殊含义的标识符 。

| 分类 | 关键字 | | | | | |
| ---- | ------ | ------ | ------ | ------ | ------ | ------ |
| 访问控制 | private |protected|public||||
| 类，方法和变量修饰符 | abstract |class|extends|final|implements|interface|
|  | native |new|static|strictfp|synchronized|transient|
|  | volatile | enum      |            |          |              |           |
| 程序控制 | break |continue|return|do|while|if|
|                      | else     | for       | instanceof | switch   | case         | *default* |
|  | assert ||||||
| 错误处理 | try |catch|throw|throws|finally||
| 包相关 | import |package|||||
| 基本类型 | boolean |byte|char|double|float|int|
|  | long     |short|            ||||
| 变量引用 | super |this|void||||
| 保留字 | goto |const|||||

## default

- 在程序控制中，当在 `switch` 中匹配不到任何情况时，可以使用 `default` 来编写**默认匹配**的情况。
- 在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 `default` 关键字来定义一个**方法的默认实现**。
- 在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 `default`，但是这个修饰符加上了就会报错。

## native

- JNI是Java Native Interface的 缩写。从Java 1.1开始，Java Native Interface (JNI)标准成为java平台的一部分，它允许**Java代码和其他语言写的代码进行交互**。JNI一开始是为了本地已编译语言，尤其是C和C++而设计 的，但是它并不妨碍你使用其他语言，只要调用约定受支持就可以了。
- 使用java与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的，比如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI标准至少保证本地代码能工作在任何Java 虚拟机实现下。

```tex
·编写带有native声明的方法的java类
·使用javac命令编译所编写的java类
·使用javah -jni java类名生成扩展名为h的头文件
·使用C/C++（或者其他编程想语言）实现本地方法
·将C/C++编写的文件生成动态连接库=
```

## for 

### fori

```java
for (int i = 0; i < 10; i++) {
     //循环语句块
}

for (int i = 10; i > 0; i--) {
     //循环语句块
}
```

两个循环变量

```java
static boolean isPalindrome(String str) {
    for (int i = 0, j = str.length() - 1; i < str.length() / 2; i++, j--) {
        if (str.charAt(i) != str.charAt(j)) {
            return false;
        }
    }
    return true;
}
```

### foreach

```java
for(元素类型type 元素变量value:数组名/Iterable 实例){
          引用x的java语句
 }
```

``````java
int [] array = {1,2,3};
for(int i : array){
  System.out.println(i);
}

List list = new ArrayList();
list.add(1);
list.add(2);
list.add(3);
for(Object obj : list){
    System.out.println(obj);
}
``````

实际上：

1. **对于数组，foreach 循环实际上还是用的普通的 for 循环**
2. **对于集合，foreach 循环实际上是用的 iterator 迭代器迭代**

```java
// 反编译class文件内容
int array[] = {1,2,3};
int [] array$ = array;
for(int len$ = array$.length, i$ = 0; i$<len$; ++i$ )
{
    int i = array$[i$];
    {
        System.out.println(i);
    }
}


List list = new ArrayList();
list.add(1);
list.add(2);
list.add(3);
for(java.util.Iterator i$ = list.iterator(); i$.hasNext();)
{
    String s = (String) i$.next();
    {
        System.out.println(s);
    }
}
```

-----

# 运算符

## 自增自减

- 前缀：先自增/减再赋值；
  - `b = ++a`，先自己增加 1，再赋值给 b；
  - 即`++a`输出的是a+1；
- 后缀：先赋值再自增/减；
  - `b = a++` ，先赋值给 b，再自己增加 1；
  - 即`a++`输出的是a；

## 移位运算符

左移`<<`、带符号右移 `>>` 和无符号右移`>>>`。`double`，`float` 在二进制中的表现比较特殊，不能来进行移位操作。实际上支持的类型只有`int`和`long`，编译器在对`short`、`byte`、`char`类型进行移位前，都会将其转换为`int`类型再操作。

- `<<` :**左移运算符**，向左移若干位，高位丢弃，低位补零。`x << 1`,**相当于 x 乘以 2**(不溢出的情况下)。
- `>>` :**带符号右移**，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> 1`,**相当于 x 除以 2**。
- `>>>` :**无符号右移**，忽略符号位，空位都以 0 补齐。

**移位的位数超过数值所占有的位数**

当 int 类型左移/右移位数大于等于 32 位操作时，会先**求余（%）后再进行左移/右移操作**。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。long 类型进行左移/右移操作时，余操作的基数为64。

`x<<42`等同于`x<<10`，`x>>42`等同于`x>>10`，`x >>>42`等同于`x >>> 10`。

------

# 基本数据类型和包装类型

|基本类型|位数|字节|默认值|取值范围|
| ---- | ---- | ---- | ---- | ---- |
|byte|8|1|0|-128 ~ 127|
|short|16|2|0|-32768（-2^15） ~ 32767（2^15 - 1）|
|int|32|4|0|-2147483648 ~ 2147483647|
|long|64|8|0L|-9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1）|
|char|16|2|'u0000'|0 ~ 65535（2^16 - 1）|
|float|32|4|0f|1.4E-45 ~ 3.4028235E38|
|double|64|8|0d|4.9E-324 ~ 1.7976931348623157E308|
|boolean|1||false|true、false|

Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占**存储空间大小的不变性**是 Java 程序更具可移植性的原因之一。

1. `long` 类型要在数值后面加上 **L**，否则将作为整型解析。
2. `char a = 'h'`:单引号，`String a = "hello"` :双引号。

3. 这八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。

## 基本类型和包装类型的区别

- **用途**

  - 除了定义一些常量和局部变量之外，在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。
  - **包装类型可用于泛型**，而基本类型不可以；

- **存储方式**

  - 基本数据类型的局部变量存放在 Java 虚拟机栈中的**局部变量表**中；
  - 基本数据类型的成员变量（未被 `static` 修饰 ）**存放在 Java 虚拟机的堆**中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中；
  - > **为什么说是”几乎“所有对象实例都存在于堆中呢？** 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行**逃逸分析**，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过**标量替换来实现栈上分配**，而避免堆上分配内存；
    >
    > **基本数据类型存放在栈中是一个常见的误区！** 基本数据类型的成员变量如果没有被 `static` 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。
    >
    > ```java
    > class BasicTypeVar{
    >   private int x;
    > }
    > ```

- **占用空间**

  - 相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小；

- **默认值**

  - 成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`；

- **比较方式**

  - 对于基本数据类型来说，`==` 比较的是值；
  - 对于包装数据类型来说，`==` 比较的是对象的内存地址；
  - 所有整型包装类对象之间值的比较，应全部使用 `equals()` 方法。


## 包装类型的缓存机制

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

- `Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

- 如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。

- 两种浮点数类型的包装类 `Float`,`Double` 并没有实现缓存机制。

```java
// Integer缓存机制
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static {
        // high value may be configured by property
        int h = 127;
    }
}

//Character缓存机制
public static Character valueOf(char c) {
    if (c <= 127) { // must cache
      return CharacterCache.cache[(int)c];
    }
    return new Character(c);
}

private static class CharacterCache {
    private CharacterCache(){}
    static final Character cache[] = new Character[127 + 1];
    static {
        for (int i = 0; i < cache.length; i++)
            cache[i] = new Character((char)i);
    }

}

// Boolean缓存机制
public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
}
```

```java
// Float, Double 并没有实现缓存机制
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true

Float i11 = 333f;
Float i22 = 333f;
System.out.println(i11 == i22);// 输出 false

Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false
```

**整型包装类对象之间值的比较**

```java
Integer i1 = 40; // 等价于Integer i1=Integer.valueOf(40)
Integer i2 = new Integer(40); // 直接创建新的对象
System.out.println(i1==i2); // False
```

- `Integer i1=40` 这一行代码会发生**装箱**，也就是说这行代码等价于 `Integer i1=Integer.valueOf(40)` 。因此，`i1` 直接使用的是缓存中的对象。
- 而`Integer i2 = new Integer(40)` 会直接创建新的对象。
- **所有整型包装类对象之间值的比较，应全部使用 equals 方法比较**。

![img](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/1021%20java%E6%95%B4%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83.png)

## 自动装箱与拆箱

- **装箱**：将基本类型用它们对应的引用类型包装起来；
  - 调用了 包装类的`valueOf()`方法；
- **拆箱**：将包装类型转换为基本数据类型；
  - 调用了 `xxxValue()`方法。
- **频繁拆装箱会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**

```java
Integer i = 10;  //装箱 Integer i = Integer.valueOf(10)
int n = i;   //拆箱 int n = i.intValue()
// 对应的字节码
   L1
    LINENUMBER 8 L1
    ALOAD 0
    BIPUSH 10
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;
   L2
    LINENUMBER 9 L2
    ALOAD 0
    ALOAD 0
    GETFIELD AutoBoxTest.i : Ljava/lang/Integer;
    INVOKEVIRTUAL java/lang/Integer.intValue ()I
    PUTFIELD AutoBoxTest.n : I
    RETURN
// 频繁拆装箱
private static long sum() {
    // 应该使用 long 而不是 Long
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
        sum += i;
    return sum;
}
```

## 浮点数运算精度丢失

与计算机保存浮点数的机制有很大关系。计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。

```java
float a = 2.0f - 1.9f;
float b = 1.8f - 1.7f;
System.out.println(a);// 0.100000024
System.out.println(b);// 0.099999905
System.out.println(a == b);// false
```

`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。

```java
BigDecimal a = new BigDecimal("1.0");
BigDecimal b = new BigDecimal("0.9");
BigDecimal c = new BigDecimal("0.8");

BigDecimal x = a.subtract(b);
BigDecimal y = b.subtract(c);

System.out.println(x); /* 0.1 */
System.out.println(y); /* 0.1 */
System.out.println(Objects.equals(x, y)); /* true */
```

## 超过 long 的数据

- Java 中，64 位 long 整型是最大的整数类型。

- `BigInteger` 内部使用 `int[]` 数组来存储任意大小的整形数据。
  - 相对于常规整数类型的运算来说，`BigInteger` 运算的效率会相对较低。

```java
long l = Long.MAX_VALUE;
System.out.println(l + 1); // -9223372036854775808
System.out.println(l + 1 == Long.MIN_VALUE); // true
```

-----

# Object

Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：

```java
// getClass native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
public final native Class<?> getClass()
// hashCode native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
public native int hashCode()
// equals 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
public boolean equals(Object obj)
// clone native 方法，用于创建并返回当前对象的一份拷贝。
protected native Object clone() throws CloneNotSupportedException
// toString 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
public String toString()
// notify native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
public final native void notify()
// notifyAll native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
public final native void notifyAll()
// wait native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
public final native void wait(long timeout) throws InterruptedException
// wait 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。
public final void wait(long timeout, int nanos) throws InterruptedException
// wait 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
public final void wait() throws InterruptedException
// finalize 实例被垃圾回收器回收的时候触发的操作
protected void finalize() throws Throwable { }
```

## == 和 equals

- 对于基本数据类型来说，`==` 比较的是值。
- 对于引用数据类型来说，`==` 比较的是**对象的内存地址**。
  - 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。
- **`equals()`** 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类，因此所有的类都有`equals()`方法。
  - **类没有重写 `equals()`方法**：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。
  - **类重写了 `equals()`方法**：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

```java
String a = new String("ab"); // a 为一个引用
String b = new String("ab"); // b为另一个引用,对象的内容一样
String aa = "ab"; // 放在常量池中
String bb = "ab"; // 从常量池中查找
System.out.println(aa == bb);// true
System.out.println(a == b);// false
System.out.println(a.equals(b));// true
System.out.println(42 == 42.0);// true
```

- `String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。

- 创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。

```java
// Object中的equals
public boolean equals(Object obj) {
    return (this == obj);
}

// String中的equals
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}

// 现在String中的equals，支持Latin1和UTF-16
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    return (anObject instanceof String aString)
        && (!COMPACT_STRINGS || this.coder == aString.coder)
        && StringLatin1.equals(value, aString.value);
}
// StringLatin1:
@IntrinsicCandidate
public static boolean equals(byte[] value, byte[] other) {
    if (value.length == other.length) {
        for (int i = 0; i < value.length; i++) {
            if (value[i] != other[i]) {
                return false;
            }
        }
        return true;
    }
    return false;
}
```

## hashCode

- 获取哈希码（`int` 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。
-  定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是：`Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的。
- 哈希表存储的是键值对(key-value)，它的特点是：**能根据“键”快速的检索出对应的“值”。这其中就利用到了哈希码！（可以快速找到所需要的对象）**

> 该方法在 **Oracle OpenJDK8** 中默认是 "使用线程局部状态来实现 Marsaglia's xor-shift 随机数生成", 并不是 "地址" 或者 "地址转换而来", 不同 JDK/VM 可能不同在 **Oracle OpenJDK8** 中有六种生成方式 (其中第五种是返回地址), 通过添加 VM 参数: -XX:hashCode=4 启用第五种。参考源码:
>
> - https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/globals.hpp（1127 行）
> - https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp（537 行开始）

我们以“`HashSet` 如何检查重复”为例子来说明为什么要有 `hashCode`？

> 当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。

其实， `hashCode()` 和 `equals()`都是用于比较两个对象是否相等。

**那为什么 JDK 还要同时提供这两个方法呢？**

这是因为在一些容器（比如 `HashMap`、`HashSet`）中，有了 `hashCode()` 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进`HashSet`的过程）！

我们在前面也提到了添加元素进`HashSet`的过程，如果 `HashSet` 在对比的时候，同样的 `hashCode` 有多个对象，它会继续使用 `equals()` 来判断是否真的相同。也就是说 `hashCode` 帮助我们大大缩小了查找成本。

**那为什么不只提供 `hashCode()` 方法呢？**

由于哈希碰撞，`hashCode` 值相等并不代表两个对象就相等。 `hashCode()` 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 `hashCode` )。

- `hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。
- `hashCode` 值相等并且`equals()`方法也返回 `true`，才认为这两个对象相等。
- `hashCode` 值不相等，则这两个对象不相等。

**重写 equals() 时必须重写 hashCode() 方法**

- 因为两个相等的对象的 `hashCode` 值必须是相等。也就是说如果 **`equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等**。

- 如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。这就导致哈希表中会出现两个相等的对象。

  ```java
  private static class Person {         
      int age;
      String name;
      
      @Override
      public int hashCode(){  
          int nameHash =  name.toUpperCase().hashCode();
          return nameHash ^ age;
      }
  ```

-----

# String

## String不可变性

[如何理解 String 类型值的不可变？ - 知乎提问](https://www.zhihu.com/question/20618891/answer/114125846)

不是在原内存地址修改数据，而是重新指向新对象：

![img](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/1021%20java%20string%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7.webp)

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    private final char value[];
	//...
}
```
- 保存字符串的数组被 `final` 修饰且为私有的，`String`中的方法都没有动Array中的元素，并且`String` 类没有提供/暴露修改这个字符串的方法。
- 整个`String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。
> `String` 类中使用 `final` 关键字修饰字符数组来保存字符串，但这不是根本原因：
>
> 被 `final` 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是**引用类型则不能再指向其他对象**。
>
> 因此，虽然value是不可变，也只是引用地址不可变，但Array数组是可变的，即这个数组保存的字符串是可变的。
>
> ![img](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/1021%20java%20string%E4%B8%8D%E5%8F%AF%E5%8F%98final.webp)
>
> 也就是说Array变量只是stack上的一个引用，数组的本体结构在head堆。String类中value用final修饰，只是stack中叫value的引用地址不可变，但堆中array本身的数据是可变的。
>
> ```java
> final int[ ] value={1,2,3}int[ ] another={4,5,6};
> value=another;//编译器报错，final不可变
> // value用final修饰，编译器不允许我把value指向堆区另一个地址。但如果我直接对数组元素动手，分分钟搞定。
> final int[ ] value={1,2,3};
> value[2]=100;//这时候数组里已经是{1,2,100}
> ```

> **Java 9 将 `String` 的底层实现由 `char[]` 改成了 `byte[]` **
>
> 新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，`byte` 占一个字节(8 位)，`char` 占用 2 个字节（16），`byte` 相较 `char` 节省一半的内存空间。JDK 官方表示绝大部分字符串对象只包含 Latin-1 可表示的字符。如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，`byte` 和 `char` 所占用的空间是一样的。
>

> **补充ASCII、UNICODE、LATIN-1、UTF-8-16-32**
>
> ***ASCII***
>
> - 单字节，在 0 ~ 127 范围是基础码，在128 ~255 是扩展码；
>
> - 在0 ~ 127范围内是全球标准，所有单字节编码（latin-1）,或长度可变编码（utf-8）都兼容。而 -1 ~ -128 范围则不兼容，每种编码规范所定义的标准都不同；
>
> ***Latin-1***
>
> 1. latin-1 就是 iso-8895-1;
>
> 2. latin-1 是单字节编码； 
> 3. 在 0 ~ 127 范围与 ascii 的一致；在128 ~ 255 则不同； 
> 4.  因为latin-1(ISO-8859-1)编码范围使用了单字节内的所有空间，在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流都不会被抛弃。
> 5. 虽然Unicode中的前256个字符及编码值与Latin-1完全一致，但UTF-8只对前128个即ASCII字符采用单字节编码，其余128个Latin-1字符是采用2个字节编码。因此ASCII编码的文件可以直接以UTF-8方式读取，而Latin-1的文件若包含值为128-255的字符则不可以。
>
> ***UNICODE***
>
> - 一种规范，只是为全球定义了每一个字符的唯一的二进制编号，但并未指定值以何种形式存储。
> - UNICODE规范的常见实现方式：UTF-8、UTF-16、UTF-32。
>
> ***UTF-8***
>
> 不同范围内UNICODE的字符，UTF-8所存储的字节数都不同，用1到4个字节编码，是可变长度的编码方式。第一个字节leading byte+后续字节continuation byte。
>
> - 0xxxxxxx：单字节编码; 0000 ~ 007F; 1 Byte;
> - 110xxxxx 10xxxxxx：双字节编码; 0080 ~ 07FF; 2 Byte;
> - 1110xxxx 10xxxxxx 10xxxxxx：三字节编码;  0800 ~ FFFF; 3 Byte;
> - 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码; 10000 ~ 1FFFFF; 4 Byte;
> - 如 "田" 01110101,00110000 U+7530：1110*0111*, 10*010100*, 10*110000*
>
> ***UTF-16***
>
> ![img](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/1022%20UTF16.webp)
>
> 编码长度既是可变，亦是固定：采用存储的字节长度为2Byte 或 4Byte(lead/trail surrogate pair)。
>
> D800–DBFF和DC00–DFFF为保留区间，若落在D800–DBFF则作为lead surrogate，DC00–DFFF为trail surrogate；
>
> UTF-16编码分为 UTF-16 little endian（LE，小端，将低序字节存储在起始地址） 和 UTF-16 big endian （BE，大端，将高序字节存储在起始地址）
>
> - 如"中" 4E2D: LE为 0~15 *4E* 15~31 *2D*; BE为 0~15 *2D* 15~31 *4E*；
> - windows 采用是 utf-16 le ,而 mac 采用是 utf-16 be；
>
> UTF-16与UTF-8都是self-synchronizing的，即某个16bit是否是一个字符的开始无需检查其前一个或者后一个16bit。与UTF-8的不同之处是，UTF-16不支持从某个随机的字节开始读取。如0041, D801DC01，若第一个字节丢失即从第二个字节读取，则UTF-16认为是41D8,01DC,01，而UTF-8不存在这个问题。
>
> ***UTF-32***
>
> 每个字符都采用 4byte 字节来存储，浪费存储空间。
>
> ***BOM(byte-order mark)***
>
> - 标识字节顺序，即大端小端，该符号位于文本序列起始字节之前；
> - UTF-8中的BOM是 **0xEF,0xBB,0xBF**，但UTF8编码单位是字节，字节的先后顺序在编码、传输和解码过程中均不改变，因此BOM在UTF8中的唯一作用是标识序列使用的是UTF8编码，在由其它使用BOM的编码转换为UTF8编码的情况下，建议在UTF8序列中保留BOM以便转换回原编码的时候不丢失BOM信息；
> - UTF-16中为**U+FEFF**（BE）和**U+FFFE**（LE），可以使用编码方式UTF-16BE和UTF-16LE来显式地标明字节顺序，当使用了UTF-16BE和UTF-16LE时，BOM不应该再出现在字节序列中，很多应用直接忽略该字符若其仍然存在；
> - UTF-16中为0000FEFF和FFFE0000。

## String、StringBuffer、StringBuilder 的区别

***可变性***

- `String` 是不可变的

- `StringBuilder` 与 `StringBuffer` 可变；
  - 都继承自 `AbstractStringBuilder` 类；
  - 在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰；
  - 最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法。

```java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
    public AbstractStringBuilder append(String str) {
        if (str == null)
            return appendNull();
        int len = str.length();
        ensureCapacityInternal(count + len);
        str.getChars(0, len, value, count);
        count += len;
        return this;
    }
  	//...
}
```

**线程安全性**

- `String` 中的对象是不可变的，也就可以理解为常量，线程安全；

- `StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是**线程安全**的；`StringBuilder` 并没有对方法进行加同步锁，所以是**非线程安全**的；
  - `AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。

**性能**

- 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象；

- `StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用；

- 相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**总结**

1. 操作少量的数据: 适用 `String`；
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`；
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`。

## 字符串常量池

 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

```java
// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa==bb);// true
```

## 常见操作

### 字符串拼接 "+" or StringBuilder？

[还在无脑用 StringBuilder？来重温一下字符串拼接吧](https://juejin.cn/post/7182872058743750715)

- Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。
- 字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

```java
String str1 = "he";
String str2 = "llo";
String str3 = "world";
String str4 = str1 + str2 + str3;
```

Java8字节码：

![img](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/1022%20java%20string%E6%8B%BC%E6%8E%A5%E5%AD%97%E8%8A%82%E7%A0%81.png)

在循环内使用“+”进行字符串拼接，存在缺陷：**编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象**。`StringBuilder` 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 `StringBuilder` 对象。

```java
String[] arr = {"he", "llo", "world"};
String s = "";
for (int i = 0; i < arr.length; i++) {
    s += arr[i];
}
System.out.println(s);
```

![img](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/1022%20java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E5%AD%97%E8%8A%82%E7%A0%812.png)

如果直接使用 `StringBuilder` 对象进行字符串拼接的话，就不会存在这个问题了。

```java
String[] arr = {"he", "llo", "world"};
StringBuilder s = new StringBuilder();
for (String value : arr) {
    s.append(value);
}
System.out.println(s);
```

![img](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/1022%20java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5stringbuilder%E5%AD%97%E8%8A%82%E7%A0%81.png)

> 不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 `makeConcatWithConstants()` 来实现，而不是大量的 `StringBuilder` 了。这个改进是 JDK9 的 [JEP 280open in new window](https://openjdk.org/jeps/280) 提出的，这也意味着 JDK 9 之后，你可以放心使用“+” 进行字符串拼接了。关于这部分改进的详细介绍，推荐阅读这篇文章：还在无脑用 [StringBuilder？来重温一下字符串拼接吧open in new window](https://juejin.cn/post/7182872058743750715) 。

### 字符串对象创建

```java
String s1 = new String("abc");// 这句话创建了几个字符串对象？
```

- 如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。

![img](https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/1022%20java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.png)

`ldc` 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象，并将该字符串对象的引用保存到字符串常量池中。

- 如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。

```java
// 字符串常量池中已存在字符串对象“abc”的引用
String s1 = "abc";
// 下面这段代码只会在堆中创建 1 个字符串对象“abc”
String s2 = new String("abc");
```

### String.intern()

`String.intern()` 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：

- 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。
- 如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。

```java
/**
 * Returns a canonical representation for the string object.
 * <p>
 * A pool of strings, initially empty, is maintained privately by the
 * class {@code String}.（常量池）
 * <p>
 * When the intern method is invoked, if the pool already contains a
 * string equal to this {@code String} object as determined by
 * the {@link #equals(Object)} method, then the string from the pool is
 * returned. Otherwise, this {@code String} object is added to the
 * pool and a reference to this {@code String} object is returned.
 * <p>
 * It follows that for any two strings {@code s} and {@code t},
 * {@code s.intern() == t.intern()} is {@code true}
 * if and only if {@code s.equals(t)} is {@code true}.
 * <p>
 * All literal strings and string-valued constant expressions are
 * interned. String literals are defined in section {@jls 3.10.5} of the
 * <cite>The Java Language Specification</cite>.
 *
 * @return  a string that has the same contents as this string, but is
 *          guaranteed to be from a pool of unique strings.
 */
// 在堆中创建字符串对象”Java“
// 将字符串对象”Java“的引用保存在字符串常量池中
String s1 = "Java";
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s2 = s1.intern();
// 会在堆中在单独创建一个字符串对象
String s3 = new String("Java");
// 直接返回字符串常量池中字符串对象"Java"对应的引用
String s4 = s3.intern();
// s1 和 s2 指向的是堆中的同一个对象
System.out.println(s1 == s2); // true
// s3 和 s4 指向的是堆中不同的对象
System.out.println(s3 == s4); // false
// s1 和 s4 指向的是堆中的同一个对象
System.out.println(s1 == s4); //true
```

### 其他操作

-  将字符串转化为字符数组

```java
// toCharArray
String str = "Hello";
char[] charArray = str.toCharArray();

// 手写toCharArray
String str = "Hello";
char[] charArray = new char[str.length()]; // 创建字符数组，长度与字符串相同
for (int i = 0; i < str.length(); i++) {
    charArray[i] = str.charAt(i); // 逐个获取字符并存储到字符数组中
```

- 字符串转字符串数组

```java
String str = "apple,banana,carrot";
String[] strArray = str.split(",");
```

- 字符串转整数数组

```java
String str = "1 2 3 4 5";
String[] strArray = str.split(" ");
int[] intArray = new int[strArray.length];
for (int i = 0; i < strArray.length; i++) {
    intArray[i] = Integer.parseInt(strArray[i]);
}

String s = "1 2 3 4 5";
int[] intArray = Arrays.stream(s.split(" ")).mapToInt(Integer::parseInt).toArray();
// 1. s.split(" ")：使用空格作为分隔符，将字符串 s 分割成多个子字符串，并返回一个字符串数组。
// 2. Arrays.stream(...)：将上一步得到的字符串数组转换为一个流（Stream）对象。
// 3. mapToInt(Integer::parseInt)：对流中的每个元素执行映射操作，将其转换为整数。这里使用了方法引用 Integer::parseInt，将字符串转换为对应的整数值。
// 4. toArray()：将流中的元素收集到一个数组中。
// 5. 最后，将结果数组赋值给数组，它的类型是 int[]，即整型数组
```

- 字符数组转字符串

```java
char[] charArray = {'H', 'e', 'l', 'l', 'o'};
String str = "";
// 使用构造函数
str = new String(charArray);
// 使用valueOf
str = String.valueOf(charArray);
```

## String 类型的变量和常量做“+”运算时发生了什么?（常量折叠）

```java
String str1 = "str";
String str2 = "ing";
String str3 = "str" + "ing";
String str4 = str1 + str2;
String str5 = "string";
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
```

**对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。**

编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 **常量折叠(Constant Folding)** 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。对于 `String str3 = "str" + "ing";` 编译器会给你优化成 `String str3 = "string";` 。

并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：

- 基本数据类型( `byte`、`boolean`、`short`、`char`、`int`、`float`、`long`、`double`)以及字符串常量。
- `final` 修饰的基本数据类型和字符串变量
- 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）

**引用的值在程序编译期是无法确定的，编译器无法对其进行优化。**

对象引用和“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

```java
String str4 = new StringBuilder().append(str1).append(str2).toString();
```

我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 `StringBuilder` 或者 `StringBuffer`。

不过，字符串使用 `final` 关键字声明之后，可以让编译器当做常量来处理。

```java
final String str1 = "str";
final String str2 = "ing";
// 下面两个表达式其实是等价的
String c = "str" + "ing";// 常量池中的对象
String d = str1 + str2; // 常量池中的对象
System.out.println(c == d);// true
```

被 `final` 关键字修饰之后的 `String` 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。

如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。

示例代码（`str2` 在运行时才能确定其值）：

```java
final String str1 = "str";
final String str2 = getStr();
String c = "str" + "ing";// 常量池中的对象
String d = str1 + str2; // 在堆上创建的新的对象
System.out.println(c == d);// false
public static String getStr() {
      return "ing";
}
```

## Java9中的字符串拼接

Java 9 里字符串拼接的字节码使用了 **`InvokeDynamic`**。

```java
$ javac Concat.java
$ javap -c Concat
      ...
      13: aload_2
      14: aload_3
      15: aload         4
      17: invokedynamic #6,  0              // InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
      ...
```

```java
CallSite callSite = StringConcatFactory.makeConcatWithConstants(   
    MethodHandles.lookup(), 
    "", 
    MethodType.methodType(String.class, String.class, String.class, String.class),
    "[[[ \u0001\u0002 \u0001\u0002 \u0001 ]]]",
    "!",
    "~" ); 
System.out.println((String)callSite.dynamicInvoker().invokeExact("Hello", "World", "Invoke Dynamic"));
```

上面这段代码输出的结果是 `[[[ Hello! World~ Invoke Dynamic ]]]`。 可以看出来，上面的 `makeConcatWithConstants` 其实就是以 `[[[ \u0001\u0002 \u0001\u0002 \u0001 ]]]` 作为了一个模板。 第一次调用的时候可以理解成它把模板填充了一半，把两处的 `\u0002` 分别用 `!` 和 `~` 这两个参数替换了， 变成 `[[[ \u0001, \u0001~ \u0001 ]]]`。这个时候它返回的 `CallSite` 包含了一个 `MethodHandle`，可以进一步调用。 而再次调用这个 `MethodHandle` 时，它就把剩下的三处 `\u0001` 给用参数给填充上了，生成了我们看到的输出字符串。

<img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/1022%20java9%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5.png" alt="image-20231022120413153" style="zoom:50%;" /><img src="https://propane.oss-cn-nanjing.aliyuncs.com/typora_pic/1022%20java9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A52.png" alt="image-20231022120658659" style="zoom: 40%;" />

而实际上，字节码里用到的 `InvokeDynamic` 所做的也就是我们上面做的。`str1 + str2 + str3` 对应的模板是 `\u0001\u0001\u0001`。 JVM 在执行到这一条 `InvokeDynamic` 指令时会自动使用 `makeConcatWithConstants` 对三个字符串的拼接操作进行优化，生成一个对应的 `CallSite` 对象， 最后用优化过的 `CallSite` 对象对字符串进行拼接。此后此处所有的字符串拼接都会使用同一个 `CallSite` 对象。

> 这里编译器只需要生成一句 `InvokeDynamic` 指令（以及对应的 `makeConcatWithConstants` 的初始参数），不需要担心性能优化。 这样使得在编译器升级时我们不必为了性能而重新编译之前的代码。
>
> 想想看，如果编译器生成了 `new StringBuilder(a.length() + b.length())...` 的代码， 那么在我们开启字符串压缩并且确认自己要处理 CJK 字符的时候，我们岂不是需要用某种奇妙的编译器选项让上面的代码重新编译为 `new StringBuilder((a.length() + b.length()) * 2)...`？因为目前的实现里 `StringBuilder` 默认按压缩处理，预分配的空间是 `N` 个 `byte` 而不是 `N` 个 `char`。
>
> 使用 `InvokeDynamic` 可以让 JVM 避免 boxing 和 unboxing 的开销。
>
> 我们上面手动的 `MethodHandle` 是必须把 `int` 变为 `Integer` 再传递进参数的。但是 `InvokeDynamic` 作为 JVM 直接支持的字节码， 它可以直接接受 `int` 之类的类型作为参数。（是的，Java 9 后 `"Hello" + 123` 这种拼接其实也是由 `InvokeDynamic` 实现的。）

***总结***

在 Java 9 及以后的版本，请大胆使用 `a + b + c + ...`。

- Java 9 后这里的字符串拼接使用了 `InvokeDynamic` 指令，默认会准确计算长度，只进行一次内存分配。 同时，它生成最终字符串时会使用字符串的内部 API，比起 `StringBuilder` 来说少了一次复制。
- Java 9 字符串拼接有不同的策略，默认策略就是上面所说的策略。其它策略在 Java 15 之后被删除掉了。

有对应的工具方法的操作，如 `String::join`，那还是用对应的方法好一点。

- `String::join` 在 Java 17 之前使用 `StringJoiner`，Java 17 之后采用了类似上面所说的优化。

在开启字符串压缩的情况下，`StringBuilder` 拼接无法压缩的（如中文）字符串会引来一次额外的内存分配。（至少 Java 19 在 `builder.setLength(0)` 后还会这样。）

-----

# 泛型

**Java 泛型（Generics）** 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。

编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 `ArrayList<Person> persons = new ArrayList<Person>()` 这行代码就指明了该 `ArrayList` 对象只能传入 `Person` 对象，如果传入其他类型的对象就会报错。

```java
ArrayList<E> extends AbstractList<E>
```

并且，原生 `List` 返回类型是 `Object` ，需要手动转换类型才能使用，使用泛型后编译器自动转换。

## 泛型的使用方式

泛型一般有三种使用方式:**泛型类**、**泛型接口**、**泛型方法**。

### 泛型类

```java
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T>{
    private T key;
    public Generic(T key) {
        this.key = key;
    }
    public T getKey(){
        return key;
    }
}
```

如何实例化泛型类：

```java
Generic<Integer> genericInteger = new Generic<Integer>(123456);
```

### 泛型接口：

```java
public interface Generator<T> {
    public T method();
}
```

实现泛型接口，不指定类型：

```java
class GeneratorImpl<T> implements Generator<T>{
    @Override
    public T method() {
        return null;
    }
}
```

实现泛型接口，指定类型：

```java
class GeneratorImpl<T> implements Generator<String>{
    @Override
    public String method() {
        return "hello";
    }
}
```

### 泛型方法

```java
   public static < E > void printArray( E[] inputArray )
   {
         for ( E element : inputArray ){
            System.out.printf( "%s ", element );
         }
         System.out.println();
    }
```

使用：

```java
// 创建不同类型数组：Integer, Double 和 Character
Integer[] intArray = { 1, 2, 3 };
String[] stringArray = { "Hello", "World" };
printArray(intArray);
printArray(stringArray);
```

注意: `public static < E > void printArray( E[] inputArray )` 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 `<E>`。

------

# 反射

- 反射赋予了框架在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。

- Spring/Spring Boot、MyBatis 等等框架中这些框架中就大量使用了反射机制，也大量使用了动态代理，而动态代理的实现也依赖反射。

```java
// 通过 JDK 实现动态代理，其中使用了反射类 Method 来调用指定的方法。
public class DebugInvocationHandler implements InvocationHandler {
    /**
     * 代理类中的真实对象
     */
    private final Object target;

    public DebugInvocationHandler(Object target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) 
        throws InvocationTargetException, IllegalAccessException {
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("after method " + method.getName());
        return result;
    }
}
```

- **注解** 的实现也用到了反射。
- 如使用 Spring 的时候 ，`@Component`注解就声明了一个类为 Spring Bean ， `@Value`注解就读取到配置文件中的值。
- 这些都是因为可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。获取到注解之后，就可以做进一步的处理。

### 优缺点

**优点**：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利

**缺点**：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。

### 获取 Class 对象的四种方式

如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:

**1. 知道具体类的情况下可以使用：**

```java
Class alunbarClass = TargetObject.class;
```

但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化

**2. 通过 `Class.forName()`传入类的全路径获取：**

```java
Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");
```

```java
public static final String ALGO = "simblock.node.consensus.ProofOfWork";
this.consensusAlgo = 
    (AbstractConsensusAlgo) Class.forName(ALGO).getConstructor(
    Node.class).newInstance(this);
```

**3. 通过对象实例`instance.getClass()`获取：**

```java
TargetObject o = new TargetObject();
Class alunbarClass2 = o.getClass();
```

**4. 通过类加载器`xxxClassLoader.loadClass()`传入类路径获取:**

```java
ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");
```

通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行。
